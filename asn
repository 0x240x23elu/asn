#!/usr/bin/env bash

########################################################################################
# -----------------------------------------------------------------------------------
#          ASN / IPv4 / IPv6 / Prefix / AS Path / Organization lookup tool
#
#               Project homepage: https://github.com/nitefood/asn
# -----------------------------------------------------------------------------------
#
# Usage:
#
#  asn <ASnumber>              -- to lookup matching ASN and BGP announcements/neighbours
#                                 data. Supports "as123" and "123" formats
#                                 (case insensitive)
#
#  asn [-n|-d] <IPv4/IPv6>     -- to lookup matching route(4/6), IP reputation
#                              -- and ASN data
#
#  asn [-n|-d] <host.name.tld> -- to lookup matching IP(v4/v6), route and ASN data
#                                 (supports multiple IPs - e.g. DNS RR)
#
#  asn <Route>                 -- to lookup matching ASN data
#
#  asn <Organization Name>     -- to search by company name and lookup network ranges
#                                 exported by (or related to) the company
# -----------------------------------------------------------------------------------
#
# Command line switches:
#
#  -d | --detailed : Display detailed MTR hop data
#  -n | --notrace  : Disable MTR tracing for lookup results
#
########################################################################################

WhoisASN(){
	found_asname=$(whois -h whois.cymru.com " -f -w -c -p as$1" | sed 's/\ *|\ */|/g' | awk -F '[|]' '{print $3}')
	if [ "$found_asname" = "NO_NAME" ]; then
		found_asname=""
	else
		pwhois_asn_info=$(whois -h whois.pwhois.org "registry source-as=$1" | grep -E "^Org-Name:|^Create-Date:")
		found_org=$(echo -e "$pwhois_asn_info" | grep -E "^Org-Name:" | cut -d ':' -f 2 | sed 's/^[ \t]*//')
		pwhois_createdate=$(echo -e "$pwhois_asn_info" | grep -E "^Create-Date:" | cut -d ':' -f 2- | sed 's/^[ \t]*//')
		found_createdate=$(date -d "$pwhois_createdate" "+%Y-%m-%d %H:%M:%S")
	fi
}

QueryRipestat(){
	BoxHeader "BGP statistics for AS${asn} (${found_asname})"
	echo ""
	StatusbarMessage "Querying RIPEstat for BGP data"
	ripestat_data=$(curl -s "https://stat.ripe.net/data/routing-status/data.json?resource=AS$1")
	StatusbarMessage ""
	if [ -n "$ripestat_data" ]; then
		ripestat_ipv4=$(echo -e "$ripestat_data" | jq -r '.data.announced_space.v4.prefixes')
		ripestat_ipv6=$(echo -e "$ripestat_data" | jq -r '.data.announced_space.v6.prefixes')
		ripestat_bgp=$(echo -e "$ripestat_data" | jq -r '.data.observed_neighbours')
	fi
}

WhoisIP(){
	full_whois_data=$(whois "$1")
	network_whois_data=$(echo -e "$full_whois_data" | grep -i -E "^netname:|^orgname:|^org-name:|^owner:|^descr:|^country:")
	abuse_whois_data=$(echo -e "$full_whois_data" | grep -E "^OrgAbuseEmail:|^abuse-c:|^% Abuse|^abuse-mailbox:")
	hostname=$(RdnsLookup "$1")
	abusecontacts=$(AbuseLookup "$abuse_whois_data")
	[[ -z "$hostname" ]] && hostname="-"
	if [ "$SKIP_PWHOIS" = false ]; then
		PwhoisLookup "$1"
	else
		# No data in the Team Cymru and pWhois DBs. Fall back to generic whois.
		[[ -z "$network_whois_data" ]] && PrintErrorAndExit "Error: no data found for $input"
		found_asn="N/A (address not announced)"
		found_asname=""
		pwhois_org=$(echo -e "$network_whois_data" | grep -i -E "^orgname:|^org-name:|^owner:" | cut -d ':' -f 2 | sed 's/^[ \t]*//' | while read -r line; do echo -n "$line / "; done | sed 's/ \/ $//')
		[[ -z "$pwhois_org" ]] && pwhois_org="N/A"
		found_route=$(echo -e "$network_whois_data" | grep -i -m2 -E "^descr:" | cut -d ':' -f 2 | sed 's/^[ \t]*//' | while read -r line; do if [ -n "$line" ]; then echo -n "$line / "; fi; done | sed 's/ \/ $//')
		[[ -z "$found_route" ]] && found_route="N/A"
		pwhois_net=$(echo -e "$network_whois_data" | grep -i -E "^netname:" | cut -d ':' -f 2 | sed 's/^[ \t]*//' | while read -r line; do echo -n "$line / "; done | sed 's/ \/ $//')
		[[ -z "$pwhois_net" ]] && pwhois_net="N/A"
		pwhois_geo=$(echo -e "$network_whois_data" | grep -m1 -i -E "^country:" | cut -d ':' -f 2 | sed 's/^[ \t]*//')
		[[ -z "$pwhois_geo" ]] && pwhois_geo="N/A"
	fi
	indent=$(( longest+4 ))
	if [ -n "$found_asname" ]; then
		output_asname="${green}($found_asname)"
	else
		output_asname=""
	fi
	printf "${white}%${longest}s${default} ┌${bluebg}PTR${default} %s\n" "$1" "$hostname"
	printf "${white}%${indent}s${bluebg}ASN${default} ${red}%s %s${default}\n" "├" "$found_asn" "$output_asname"
	printf "${white}%${indent}s${bluebg}ORG${default} ${green}%s${default}\n" "├" "$pwhois_org"
	printf "${white}%${indent}s${bluebg}NET${default} ${yellow}%s (%s)${default}\n" "├" "$found_route" "$pwhois_net"
	printf "${white}%${indent}s${bluebg}ABU${default} ${blue}%s${default}\n" "├" "$abusecontacts"
	[[ "$REPUTATION_LOOKUP" = true ]] && last_symbol="├" || last_symbol="└"
	printf "${white}%${indent}s${bluebg}GEO${default} ${magenta}%s${default}\n" "$last_symbol" "$pwhois_geo"
	[[ "$REPUTATION_LOOKUP" = false ]] && echo ""
}

LookupASNAndRouteFromIP(){
	found_route=""
	found_asn=""
	found_asname=""
	output=$(whois -h whois.cymru.com " -f -p $1" | sed 's/\ *|\ */|/g')
	found_asn=$(echo "$output" | awk -F'[|]' 'NR==1{print $1}')
	found_asname=$(echo "$output" | awk -F'[|]' 'NR==1{print $4}')
	found_route=$(echo "$output" | awk -F'[|]' 'NR==1{print $3}')
	if [ "$found_asname" = "NA" ]; then
		# Team Cymru has no data for this IP. Try pWhois next
		output=$(whois -h whois.pwhois.org "$1" | sed 's/\: /:/')
		found_asn=$(echo "$output" | grep -E "^Origin-AS:" | cut -d ':' -f 2)
		found_asname=$(echo "$output" | grep -E "^AS-Org-Name:" | cut -d ':' -f 2)
		found_route=$(echo "$output" | grep -E "^Prefix:" | cut -d ':' -f 2)
	fi
	if [ -z "$found_asname" ]; then
		# Team Cymru and pWhois have no data about this IP. Inform WhoisIP() that we will have to fall back to a generic whois lookup.
		SKIP_PWHOIS=true
	else
		SKIP_PWHOIS=false
	fi
}

ResolveHostnameToIPList(){
	raw_host_output=$(host "$1" 2>/dev/null)
	if echo -e "$raw_host_output" | grep -q "mail is handled"; then
		host_output=$(echo "$raw_host_output" | grep -B100 -A0 -m1 "mail is handled" | sed '$d')
	else
		host_output="$raw_host_output"
	fi
	ip=$(echo "$host_output" | grep -Eo "$ipv4v6regex")
	echo -e "$ip\n"
}

PrintUsage(){
	programname=$(basename "$0")
	BoxHeader "ASN / BGP stats / IPv4v6 / Prefix / ASPath / Organization lookup tool"
	echo -e "\
	\nUsage:\n\t$programname ${green}[OPTIONS] ${blue}<TARGET>${default}\n\nOptions:\n\
	\n  ${green}-d, --detailed\n\t${default}Output detailed hop info (collected from pWhois) during the AS path trace to the ${blue}TARGET${default}
	\n  ${green}-n, --notrace\n\t${default}Disable tracing the AS path to the ${blue}TARGET${default}\n\nSupported targets:\
	\n\n  ${blue}<AS Number>${default}\n\tLookup matching and BGP announcements/neighbours data.\
	\n\t(Supports \"as123\" and \"123\" formats - case insensitive)\
	\n\n  ${blue}<IPv4/IPv6>${default}\n\tLookup matching route and ASN data\
	\n\n  ${blue}<Prefix>${default}\n\tLookup matching ASN data\
	\n\n  ${blue}<host.name.tld>${default}\n\tLookup matching IP, route and ASN data. Supports multiple IPs - e.g. DNS RR\
	\n\n  ${blue}<Organization Name>${default}\n\tSearch by company name and lookup network ranges exported by (or related to) the company\
	\n\n\nProject homepage: ${red}https://github.com/nitefood/asn${default}\n
	"
}

PwhoisLookup(){
	pwhois_output=$(whois -h whois.pwhois.org "$1")
	if echo "$pwhois_output" | grep -vq "That IP address doesn't appear"; then
		pwhois_asn=$(echo "$pwhois_output" | grep -E "^Origin-AS" | cut -d ':' -f 2 | sed 's/^ //')
		pwhois_asorg=$(echo "$pwhois_output" | grep -E "^AS-Org-Name" | cut -d ':' -f 2 | sed 's/^ //')
		# group all "Org-Name" fields on a single line
		pwhois_org=$(echo "$pwhois_output" | grep -E "^Org-Name" | cut -d ':' -f 2 | sed 's/^[ \t]*//g' | while read -r line; do echo -n "$line / "; done | sed 's/ \/ $//')
		pwhois_net=$(echo "$pwhois_output" | grep -E "^Net-Name" | cut -d ':' -f 2 | sed 's/^ //')
		# if pWhois' Net-Name=Org-Name, then it's more useful to use AS-Org-Name instead of Org-Name (unless AS-Org-Name is empty)
		if [ -n "$pwhois_asorg" ] && [ "$pwhois_net" = "$pwhois_org" ]; then
			pwhois_org="$pwhois_asorg"
		fi
		if echo "$pwhois_output" | grep -q -E "^Geo-"; then
			# use "Geo-" fields in pWhois output
			cityfield="Geo-City"
			regionfield="Geo-Region"
			ccfield="Geo-CC"
		else
			cityfield="City"
			regionfield="Region"
			ccfield="Country-Code"
		fi
		pwhois_city=$(echo "$pwhois_output" | grep -m1 -E "^${cityfield}" | cut -d ':' -f 2 | sed 's/^ //')
		pwhois_region=$(echo "$pwhois_output" | grep -m1 -E "^${regionfield}" | cut -d ':' -f 2 | sed 's/^ //')
		pwhois_cc=$(echo "$pwhois_output" | grep -m1 -E "^${ccfield}" | cut -d ':' -f 2 | sed 's/^ //')
		if [ "$pwhois_city" = "NULL" ] || [ "$pwhois_region" = "NULL" ]; then
			pwhois_geo="$pwhois_cc"
		else
			pwhois_geo="$pwhois_city, $pwhois_region ($pwhois_cc)"
		fi
	else
		pwhois_output="";
	fi
}

RdnsLookup(){
	# reverse DNS (PTR) lookup.
	# get first lookup result only (in case of multiple PTR records) and remove trailing dot and CR (Cygwin) from hostname
	rdns=$(host "$1" | awk 'NR==1{sub(/\.\r?$/, "", $NF); print $NF}')
	if echo "$rdns" | grep -E -q "NXDOMAIN|SERVFAIL"; then rdns=""; fi
	echo "$rdns"
}

AbuseLookup(){
	abuselist=""
	for abusecontact in $(echo -e "$1" | grep -E "^OrgAbuseEmail:|^abuse-c:|^% Abuse|^abuse-mailbox:" | awk '{print $NF}' | tr -d \'); do
		if echo "$abusecontact" | grep -vq '@'; then
			# $abusecontact is not an email, try a whois lookup (it should be a handle)
			resolvedabuse=$(whois "$abusecontact" | grep -E -i "^abuse-mailbox:" | awk '{print $2}' | tr -d \')
			if [ -z "$resolvedabuse" ]; then
				# whois couldn't resolve the abuse handle. Try identifying the
				# original answering whois server and forcing a lookup on the same server
				original_whois_server=$(echo -e "$full_whois_data" | grep -E "^%.*whois\..*$" | awk 'NR==1 {print $NF}' | tr -d '[]')
				if [ -n "$original_whois_server" ]; then
					# original whois server found, try manually querying it with an extended set of grep patterns
					resolvedabuse=$(whois -h "$original_whois_server" "$abusecontact" | grep -E -m1 -i "^abuse-mailbox:|^e-mail:" | awk '{print $2}' | tr -d \')
				fi
			fi
			[[ -n "$resolvedabuse" ]] && abusecontact="$resolvedabuse"
		fi
		[[ -n "$abuselist" ]] && abuselist+="\n"
		abuselist+="$abusecontact"
	done

	if [ -n "$abuselist" ]; then
		echo -e "$abuselist" | tr " " "\n" | sort -u | while read -r line; do echo -n "$line / "; done | sed 's/ \/ $//'
	else
		echo "-"
	fi
}

TraceASPath(){
	starttime=$(date +%s)
	host_to_trace="$1"
	mtr_rounds=3
	echo ""
	StatusbarMessage "Tracing path to ${bluebg}${host_to_trace}${lightgreybg}"
	# cache the previously looked-up AS to save one lookup (target/last hop)
	saved_asn=$found_asn
	saved_asname=$found_asname
	# last_resolved_ip will save us one dns resolution (mtr returns the same last hop twice)
	last_resolved_ip=""
	privateregex='/(^127\.)|(^192\.168\.)|(^10\.)|(^172\.1[6-9]\.)|(^172\.2[0-9]\.)|(^172\.3[0-1]\.)|(^::1$)|(^[fF][cCdD])/' # cheers https://stackoverflow.com/a/11327345/5377165
	# start the mtr trace in a bash coprocess to parse its output asynchronously
	coproc mtr -l -n -c"$mtr_rounds" "$host_to_trace"
	declare -a hostline_array
	declare -a dnsline_array
	declare -a pingline_array
	declare -a aspath_array
	# initialize the aspath array with our source AS
	LookupASNAndRouteFromIP "$(curl -s api64.ipify.org)"
	aspath_entry=$(printf "${red}%-6s ${green}%s${default}" "$found_asn" "$(echo "$found_asname" | cut -d ',' -f 1)" )
	aspath_array+=("$aspath_entry")
	while true; do
		# read mtr output from the bash coprocess pipe,
		# parsing raw mtr results beginning with :
		# - h ("hostline", or IPs)
		# - p ("pingline", or latencies)
		# see https://github.com/traviscross/mtr/blob/master/FORMATS
		if read -r -u "${COPROC[0]}" raw_mtr_line 2>/dev/null; then
			mtr_type=$(echo "$raw_mtr_line" | cut -d ' ' -f 1)
			mtr_hopnum=$(echo "$raw_mtr_line" | cut -d ' ' -f 2)
			mtr_data=$(echo "$raw_mtr_line" | cut -d ' ' -f 3)
			case "$mtr_type" in
				"h")
					# this is a hostline ($mtr_data is an IP address)
					hostline_array["$mtr_hopnum"]="$mtr_data"
					# do a reverse DNS lookup for the IP instead of relying on
					# mtr's dnsline results since it proved unreliable in dnsmasq scenarios.
					# See https://github.com/nitefood/asn/pull/3
					if [ "$mtr_data" != "$last_resolved_ip" ]; then
						last_resolved_ip="$mtr_data"
						hostname=$(RdnsLookup "$mtr_data")
						[[ -n "$hostname" ]] && dnsline_array["$mtr_hopnum"]="$hostname"
					fi
					;;
				"p")
					# this is a pingline ($mtr_data is a latency value in microseconds)
					cur_latency_sum=${pingline_array["$mtr_hopnum"]}
					pingline_array["$mtr_hopnum"]=$(echo "$cur_latency_sum $mtr_data" |\
					awk '{ sum = $1 + $2; printf ("%.1f\n", sum) }') # we store the total sum of reply times in the array, and will average it at display time
					;;
			esac
		else
			break
		fi
	done
	wait
	# mtr finished, parse and format results
	StatusbarMessage "Parsing collected trace output"
	trace_output=$(printf "${lightgreybg}%4s %-72s%18s     %s     ${default}" "Hop" "IP Address" "Ping avg" "AS Information")
	cur_hop_count=1
	last_hop=false
	for mtr_hopnum in "${!hostline_array[@]}"; do
		hop_ip=${hostline_array[$mtr_hopnum]}
		# AS DATA lookup
		# check if IP is in private addressing space
		if [[ $hop_ip =~ $privateregex ]]; then
			asn_data="${white}(Private network)${default}"
			pwhois_output=""
		else
			# not a private address, try saving a lookup
			# (if $hop_ip = our target, ie we're at the last hop)
			if [ "$hop_ip" = "$host_to_trace" ]; then
				found_asn=$saved_asn
				found_asname=$saved_asname
				# avoid adding the same AS multiple times in a row in the summary path
				aspath_entry=$(printf "${red}%-6s ${green}%s${default}" "${found_asn}" "$(echo "${found_asname}" | cut -d ',' -f 1)" )
				if [[ ${#aspath_array[@]} -eq 0 ]] || [[ "${aspath_array[-1]}" != "$aspath_entry" ]]; then
					aspath_array+=("$aspath_entry")
				fi
				asn_data="${red}[AS$found_asn] ${green}$found_asname${default}"
				last_hop=true
			else
				# not the last hop. Lookup hop data
				LookupASNAndRouteFromIP "$hop_ip"
				if [ -z "$found_asname" ] && [ -z "$found_route" ]; then
					# no data found, try retrieving relevant info from a generic whois lookup
					network_whois_data=$(whois "$hop_ip" | grep -i -m2 -E "^netname:|^orgname:|^org-name:|^descr:" | cut -d ':' -f 2 | sed 's/^[ \t]*//' | while read -r line; do echo -n "$line / "; done | sed 's/ \/ $//')
					if [ -z "$network_whois_data" ]; then
						asn_data="${yellow}(No data)${default}"
					else
						asn_data="${yellow}(${network_whois_data})${default}"
					fi
				else
					# lookup success
					asn_data="${red}[AS$found_asn] ${green}$found_asname${default}"
					# avoid adding the same AS multiple times in a row in the summary path
					aspath_entry=$(printf "${red}%-6s ${green}%s${default}" "$found_asn" "$(echo "$found_asname" | cut -d ',' -f 1)" )
					if [[ "${aspath_array[-1]}" != "$aspath_entry" ]]; then
						aspath_array+=("$aspath_entry")
					fi
				fi
			fi
			if [ "$DETAILED_TRACE" = "true" ]; then
				if [ "$SKIP_PWHOIS" = false ]; then
					PwhoisLookup "$hop_ip"
				else
					pwhois_asn="${red}N/A (address not announced)${default}"
					# don't display this, we're being parsed off-screen
					WhoisIP "$hop_ip" >/dev/null
				fi
			fi
		fi

		# DNS data (only used if a hostname was resolved)
		if [ -n "${dnsline_array[$mtr_hopnum]}" ]; then
			saveip=$hop_ip
			hop_ip="${dnsline_array[$mtr_hopnum]} ($saveip)"
		fi

		# PING data
		# account for missing (no reply) hops
		while [ "$mtr_hopnum" -ge "$((cur_hop_count))" ]; do
			trace_output+=$(printf "\n%3s. %-90s %10s   %s" "$cur_hop_count" "${white}???${default}" "*" "${white}(No reply)${default}")
			if [ "$DETAILED_TRACE" = "true" ]; then
				# PWHOIS lookups ON, but no valid data (no reply hop). Just add a newline for readability
				trace_output+="\n"
			fi
			((cur_hop_count++))
		done
		# data in the array item is the total sum of mtr latencies collected for this hop in microseconds.
		# convert it to milliseconds, and round it to 1 digit precision (mtr's output style)
		ping_total_usec=${pingline_array[$mtr_hopnum]}
		if [ -n "$ping_total_usec" ]; then
			ping_average_msec=$(echo "$ping_total_usec $mtr_rounds" | awk '{ avg = $1 / $2; printf( "%.1f\n", avg/1000) }')
			ping_data="$ping_average_msec ms"
		fi
		trace_output+=$(printf "\n%3s. %-90s %10s   %s" "$cur_hop_count" "${white}$hop_ip${default}" "${ping_data}" "$asn_data")
		if [ "$DETAILED_TRACE" = "true" ] && [ -n "$pwhois_output" ]; then
			trace_output+=$(printf "\n     ├${bluebg}ASN${default} ${red}%s${default}\n     ├${bluebg}ORG${default} ${green}%s${default}\n     ├${bluebg}NET${default} ${yellow}%s${default}\n     └${bluebg}GEO${default} ${magenta}%s${default}" \
				"$pwhois_asn" "$pwhois_org" "$pwhois_net" "$pwhois_geo")
			trace_output+="\n"
		elif [ "$DETAILED_TRACE" = "true" ]; then
			# PWHOIS lookups ON, but no valid data. Just add a newline for readability
			trace_output+="\n"
		fi
		[[ "$last_hop" = true ]] && break
		(( cur_hop_count++ ))
	done
	# mtr output (hostlines) parsing complete
	if [ "$last_hop" = false ]; then
		# last hop wasn't our target IP. Add a missing last hop to the trace.
		trace_output+=$(printf "\n%3s. %-90s %10s   %s" "$cur_hop_count" "${white}???${default}" "*" "${white}(No reply)${default}")
		[[ "$DETAILED_TRACE" = "true" ]] && trace_output+="\n"
	fi
	StatusbarMessage ""

	if [ "$DETAILED_TRACE" = true ]; then
		headermsg="Detailed trace to $userinput"
	else
		headermsg="Trace to $userinput"
	fi
	BoxHeader "$headermsg"
	echo -e "\n${trace_output}"
	endtime=$(date +%s)
	runtime=$((endtime-starttime))
	echo -e "\nTrace complete in $runtime seconds.\n\n"

	BoxHeader "AS path to $userinput"
	echo -en "\n  "
	for as in "${aspath_array[@]}"; do
		if [ "$as" = "${aspath_array[0]}" ]; then
			echo -en "${as} ${yellow}(Local AS)${default}"
		else
			echo -en "${as}${default}"
		fi
		if [ "$as" != "${aspath_array[-1]}" ]; then
			echo -en "\n ╭╯\n ╰"
		fi
	done
	echo -e "\n"

}

SearchByOrg(){
	unset orgs
	declare -a orgs
	echo ""
	if [ "$ORG_FILTER" = false ]; then
		StatusbarMessage "Searching for organizations matching ${bluebg}$1${lightgreybg}"
		full_org_search_data=$(whois -h whois.pwhois.org "registry org-name=$1")
		original_organizations=$(echo -e "$full_org_search_data" | grep -E "^Org-Name:" | cut -d ':' -f 2- | sed 's/^ //g' | sort -uf)
		total_orgsearch_results=$(echo -e "$original_organizations" | wc -l)
		organizations="$original_organizations"
	else
		# user chose to apply a search filter to a previous query
		if [ ${#orgfilters_array[@]} -eq 0 ] && [ ${#excl_orgfilters_array[@]} -eq 0 ]; then
			# user deleted all search filters. Revert to original query result
			organizations="$original_organizations"
			ORG_FILTER=false
		else
			StatusbarMessage "Applying filters"
			filtered_org="$original_organizations"
			# parse all inclusion filters
			for filter in "${orgfilters_array[@]}"; do
				apply_filter=$(echo -e "$filtered_org" | grep -i -- "$filter")
				if [ -z "$apply_filter" ]; then
					StatusbarMessage ""
					echo -en "${yellow}Warning: No results found for ${bluebg}${filter}${default}"
					sleep 2
					# remove last filter term
					unset 'orgfilters_array[${#orgfilters_array[@]}-1]'
				else
					filtered_org="$apply_filter"
				fi
			done
			# parse all exclusion filters
			for filter in "${excl_orgfilters_array[@]}"; do
				apply_filter=$(echo -e "$filtered_org" | grep -i -v -- "$filter")
				if [ -z "$apply_filter" ]; then
					StatusbarMessage ""
					echo -en "${yellow}Warning: No more results found if excluding ${bluebg}${filter}${default}"
					sleep 2
					# remove last filter term
					unset 'excl_orgfilters_array[${#excl_orgfilters_array[@]}-1]'
				else
					filtered_org="$apply_filter"
				fi
			done
			# have we removed all filters (because of no matches)? go back to unfiltered results
			if [ ${#orgfilters_array[@]} -eq 0 ] && [ ${#excl_orgfilters_array[@]} -eq 0 ]; then
				ORG_FILTER=false
				echo ""
			fi
			organizations="$filtered_org"
		fi
	fi
	for orgname in $organizations; do
		orgs+=("$orgname")
	done
	StatusbarMessage ""

	if [ ${#orgs[@]} -eq 0 ]; then
		# company search yielded no results
		PrintErrorAndExit "Error: organization not found"
	fi

	# Menu showing loop
	while true; do
		ShowMenu
		searchresults=""
		orgids=$(echo -e "$full_org_search_data" | grep -i -E -B1 "Org-Name: $org$" | grep "Org-ID" | cut -d ':' -f 2- | sed 's/^ //g')
		NO_ERROR_ON_INTERRUPT=true
		for ipversion in 4 6; do
			NO_RESULTS=true
			searchresults+=$(BoxHeader "IPv${ipversion} networks for organization \"${org}\"")
			# iterate over Org-IDs related to the company (in case of multiple Org-IDs for a single Org-Name)
			for orgid in $orgids; do
				StatusbarMessage "Looking up IPv${ipversion} networks for organization ${bluebg}$org${lightgreybg} (Org-ID: ${bluebg}${orgid}${lightgreybg})"
				netblocks_output=""
				if [ "$ipversion" = "4" ]; then
					# Parse IPv4 NETBLOCKS
					netblocks=$(whois -h whois.pwhois.org "netblock org-id=${orgid}" | grep -E "^*>")
					netblocks_header="            IPv4 NET RANGE                | INFO"
					for netblock in $netblocks; do
						prefix=$(echo -e "$netblock" | cut -d '>' -f 2 | cut -d '|' -f 1)
						netname=$(echo -e "$netblock" | cut -d '>' -f 2 | cut -d '|' -f 2 | tr -d ' ')
						netblock_type=$(echo -e "$netblock" | cut -d '>' -f 2 | cut -d '|' -f 3 | tr -d ' ')
						if [ "$netblock_type" = "unknown" ]; then
							nettype=""
						else
							nettype=" (${yellow}$netblock_type${default})"
						fi
						regdate=$(echo -e "$netblock" | cut -d '>' -f 2 | cut -d '|' -f 4 | tr -d ' ')
						if [ "$HAVE_IPCALC" = true ]; then
							# deaggregate IPv4 netblocks into CIDR prefixes for readability
							prefix_spacing=19
							trimmed_prefix=$(echo "$prefix" | tr -d ' ')
							prefix=$(ipcalc -r "$trimmed_prefix" | grep -A1 "deaggregate" | tail -n 1)
						else
							# no ipcalc, use direct pWhois output
							prefix_spacing=41
						fi
						netblocks_output+=$(printf "\n${blue}%${prefix_spacing}s${default} | ${green}%-45s${default} - Registered: ${magenta}%s${default}%s" "$prefix" "$netname" "$regdate" "$nettype")
					done
					[[ "$HAVE_IPCALC" = true ]] && netblocks_header="    IPv4 PREFIX     |       INFO"
				else
					# Parse IPv6 NETBLOCKS
					netblocks=$(whois -h whois.pwhois.org "netblock6 org-id=${orgid}" | grep -E "^Net-(Range|Name|Handle|Type)|^Register-Date" |\
						cut -d ':' -f 2- |\
						sed 's/^ //g' |\
						awk '{if (NR%5) {ORS=""} else {ORS="\n"}{print $0"|"}}') # cheers https://stackoverflow.com/a/35315421/5377165
					netblocks_header="                       IPv6 NET RANGE                         | INFO"
					for netblock in $netblocks; do
						prefix=$(echo -e "$netblock" | cut -d '|' -f 1)
						netname=$(echo -e "$netblock" | cut -d '|' -f 2)
						nethandle=$(echo -e "$netblock" | cut -d '|' -f 3)
						netname+=" (${nethandle})"
						netblock_type=$(echo -e "$netblock" | cut -d '|' -f 4)
						if [ "$netblock_type" = "unknown" ]; then
							nettype=""
						else
							nettype=" (${yellow}$netblock_type${default})"
						fi
						regdate=$(echo -e "$netblock" | cut -d '|' -f 5)
						prefix_spacing=61
						netblocks_output+=$(printf "\n${blue}%${prefix_spacing}s${default} | ${green}%-45s${default} - Registered: ${magenta}%s${default}%s" "$prefix" "$netname" "$regdate" "$nettype")
					done
				fi
				if [ -n "$netblocks_output" ]; then
					# Print out netblocks
					NO_RESULTS=false
					searchresults+=$(echo -e "\n${red}Org-ID: ${magenta}${orgid}${red}${default}\n${netblocks_header}${netblocks_output}")
					searchresults+="\n"
				fi
			done
			[[ "$NO_RESULTS" = "true" ]] && searchresults+="\n\t${red}No results found${default}\n"
		done
		NO_ERROR_ON_INTERRUPT=false
		StatusbarMessage ""
		echo -e "$searchresults\n${yellow}────────────────────────────────────────────────────${default}"
		# let the user choose if they want to run a quick IP lookup
		while true; do
			echo -e "\n- Enter any ${blue}IP/Prefix${default} to look it up or"
			echo -e "- Press ${yellow}ENTER${default} to return to the menu:\n"
			echo -n ">> "
			read -r choice
			# check if it's an IPv4/IPv6
			if [ -n "${choice}" ]; then
				input=$(echo "$choice" | sed 's/\/.*//g' | grep -Eo "$ipv4v6regex")
				if [ -n "$input" ]; then
					# valid IP
					echo ""
					StatusbarMessage "Looking up data for ${bluebg}${input}${lightgreybg}"
					LookupASNAndRouteFromIP "$input"
					(( longest=${#input}+1 ))
					output=$(WhoisIP "$input")
					StatusbarMessage ""
					echo -e "$output"
					continue
				else
					continue
				fi
			else
				# user pressed ENTER, go back to main organizations menu
				clear
				break
			fi
		done
	done
}

ShowMenu(){ # show selection menu for search-by-company results
	clear
	BoxHeader "Organizations matching \"$userinput\""
	if [ "$ORG_FILTER" = true ]; then
		num_inclusion_filters="${#orgfilters_array[@]}"
		num_exclusion_filters="${#excl_orgfilters_array[@]}"
		num_filters=$(( num_inclusion_filters+num_exclusion_filters ))
		[[ $num_filters = 1 ]] && s="" || s="s"
		ACTIVE_FILTERS_STRING=$'\n'"${bluebg}${black}${num_filters} Active filter${s}:${default}"

		# recap inclusion filters
		for filter in "${orgfilters_array[@]}"; do
			ACTIVE_FILTERS_STRING+=" ${lightgreybg}${filter}${default}"
		done

		# recap exclusion filters
		for filter in "${excl_orgfilters_array[@]}"; do
			ACTIVE_FILTERS_STRING+=" ${lightgreybg}${red}-${filter}${default}"
		done

		ACTIVE_FILTERS_STRING+=$'\n'
	else
		ACTIVE_FILTERS_STRING=""
	fi
	if [ "$HAVE_IPCALC" = true ]; then
		IPCALC_WARNING=""
	else
		IPCALC_WARNING=$'\n'"${yellow}Warning: program ${red}ipcalc${yellow} not found."$'\n'"Install it with ${green}apt install ipcalc${yellow}"$'\n'"to enable netblock->CIDR prefix aggregation.${default}"$'\n'
	fi
	PS3="${yellow}────────────────────────────────────────────────────${default}
$ACTIVE_FILTERS_STRING
${yellow}${#orgs[@]} of $total_orgsearch_results total results shown${default}

Choose an organization or enter:
- <${green}text${default}> to FILTER FOR A STRING
- <${blue}-${default}> to EXCLUDE A STRING
- <${blue}x${default}> to REMOVE ALL FILTERS
- <${blue}q${default}> to QUIT
$IPCALC_WARNING
>> "
	echo -e "${yellow}────────────────────────────────────────────────────${green}"
	COLUMNS=0
	set -o posix
	select choice in "${orgs[@]}"; do
		for org in "${orgs[@]}"; do
			if [[ "$org" = "$choice" ]]; then
				break 2
			fi
		done
		case "$REPLY" in
			"q"|"Q")
				exit 0
			;;
			"-")
				# add an exclusion filter
				echo -n "Enter a string to ${red}exclude${default}: "
				read -r exclusion_string
				excl_orgfilters_array+=("$exclusion_string")
				ORG_FILTER=true
				SearchByOrg
			;;
			"x"|"X")
				# reset filters
				if [ "$ORG_FILTER" = true ]; then
					unset orgfilters_array
					unset excl_orgfilters_array
					declare -a orgfilters_array
					declare -a excl_orgfilters_array
					SearchByOrg
				fi
			;;
			*)
				# apply filter to the results
				orgfilters_array+=("$REPLY")
				ORG_FILTER=true
				SearchByOrg
			;;
		esac
	done
	set +o posix
	echo ""
}

SignalsAPIQuery(){ # output saved to $signals_response
	signals_response=""
	# Authenticate to Auth0 Signals API, otherwise run anonymously
	if [ -n "$SIGNALS_TOKEN" ]; then
		signals_response=$(curl -s --request GET --url "$1" --header "accept: application/json" --header "x-auth-token: ${SIGNALS_TOKEN}")
	else
		signals_response=$(curl -s --request GET --url "$1" --header "accept: application/json")
	fi
	# check Signals output to make sure we didn't receive invalid data (eg. quota exceeded etc)
	# if it's not valid json...
	json_type=$(echo "$signals_response" | jq type 2>/dev/null)
	if [ -z "$json_type" ]; then
		# ...and it's not a "clean ip" reply...
		if echo "$signals_response" | grep -vq "Resource not found"; then
			# then fail
			StatusbarMessage ""
			PrintErrorAndExit "ERROR: Could not query Signals API (Server said: \"${signals_response}\")"
		fi
	fi
}

ReputationLookup(){
	StatusbarMessage "Looking up reputation for IP address ${bluebg}$1${lightgreybg}"
	SignalsAPIQuery "https://signals.api.auth0.com/badip/$1"
	StatusbarMessage ""
	if echo "$signals_response" | grep -q "Resource not found"; then
		IS_BADIP=false
		badip_output="${green}✓ GOOD${default}"
	else
		IS_BADIP=true
		black_count=$(echo "$signals_response" | jq '.response | length')
		[[ "$black_count" -gt 1 ]] && s="s" || s=""
		badip_output="${red}❌ BAD${default}"
	fi
	printf "${white}%${indent}s${bluebg}REP${default} ${magenta}%s${default}\n\n" "└" "$badip_output"
	if [ "$IS_BADIP" = false ]; then
		return
	fi
	badip_output="${red}❌ BAD (Address found in ${black_count} blacklist${s})${default}"
	BoxHeader "Detailed IP reputation report for $input"
	echo ""
	# parse blacklists and collect bad tags associated with the IP address
	echo -e "${bluebg} IP ADDRESS────>${default} ${white}$1"
	echo -e "${bluebg} REPUTATION────>${default} $badip_output"
	StatusbarMessage "Collecting detailed reputation data"
	global_tags=""
	blacklist_output=""
	blacklists=$(echo "$signals_response" | jq -r '.response[]')
	for blacklist in $(echo "$blacklists" | sort); do
		SignalsAPIQuery "https://signals.api.auth0.com/metadata/badip/lists/$blacklist"
		blacklist_details="$signals_response"
		name=$(echo "$blacklist_details" | jq -r '.name')
		group=$(echo "$blacklist_details" | jq -r '.group')
		site=$(echo "$blacklist_details" | jq -r '.site')
		tags=$(echo "$blacklist_details" | jq -r '.tags')
		[[ -z "$global_tags" ]] && global_tags="$tags" || global_tags+=",$tags"
		blacklist_output+="${bluebg} BLACKLIST HIT─>${default} ${red}[$group] ${yellow}${blacklist} (${name} -- ${blue}${site}${yellow})\n"
	done
	StatusbarMessage ""
	unique_tags=$(echo "$global_tags" | tr ',' '\n' | sort -u  | tr '[:lower:]' '[:upper:]')
	output_tags=""
	redbg=$'\e[30m\e[101m'
	for tag in $unique_tags; do output_tags+="${redbg} ${tag} ${default} "; done
	echo -e "${bluebg} ABUSE TAGS ───>${default} ${output_tags}"
	echo -e "${blacklist_output}"
}

PrintErrorAndExit(){
	echo -e "\n\e[30m\e[101m${1}\e[39m\e[49m\n"
	tput sgr0
	exit 1
}

Ctrl_C() {
	if [ "$NO_ERROR_ON_INTERRUPT" = true ]; then
		StatusbarMessage ""
		tput sgr0
		ShowMenu
	else
		PrintErrorAndExit "Interrupted"
	fi
}

BoxHeader() { # cheers https://unix.stackexchange.com/a/70616
	local s="$*"
	echo -e "\n${white}╭─${s//?/─}─╮
│ ${yellow}${s}${white} │
╰─${s//?/─}─╯"
	tput sgr 0
}

StatusbarMessage() { # invoke without parameters to delete the status bar message
	if [ -n "$statusbar_message" ]; then
		# delete previous status bar message
		printf "\r%${#statusbar_message}s\r" " "
	fi
	if [ -n "$1" ]; then
		statusbar_message="${lightgreybg}$1 (press CTRL-C to cancel)...${default}"
		echo -en "$statusbar_message"
	fi
}

# Color scheme
IFS=$'\n\t'
green=$'\e[32m'
magenta=$'\e[35m'
yellow=$'\e[33m'
white=$'\e[97m'
blue=$'\e[94m'
red=$'\e[31m'
black=$'\e[30m'
lightgreybg=$'\e[47m\e[30m'
bluebg=$'\e[44m\e[30m'
default=$'\e[0m'

# External API token for Auth0 Signals (IP reputation lookup)
SIGNALS_TOKEN_FILENAME="$HOME/.asn/signals_token"
REPUTATION_LOOKUP=false

# Sigint trapping
NO_ERROR_ON_INTERRUPT=false
trap Ctrl_C INT

ipv4v6regex='[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}|(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|'\
'([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|'\
'([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|'\
':((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|'\
'(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|'\
'1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))' # cheers https://stackoverflow.com/a/17871737

# Check cmdline parameters
if [[ $# -lt 1 ]]; then
	PrintUsage
	exit 1
fi
case "$1" in
	"-n"|"--notrace")
		if [[ $# -lt 2 ]]; then
			PrintUsage
			echo -e "Error: missing ${red}TARGET${default}\n"
			exit 1
		fi
		TRACEASNPATH=false
		DETAILED_TRACE=false
		userinput="$2"
		;;
	"-d"|"--detailed")
		if [[ $# -lt 2 ]]; then
			PrintUsage
			echo -e "Error: missing ${red}TARGET${default}\n"
			exit 1
		fi
		TRACEASNPATH=true
		DETAILED_TRACE=true
		userinput="$2"
		;;
	*)
		if [ "${1:0:1}" = "-" ]; then
			 PrintUsage
			 echo -e "Error: unknown option ${red}$1${default}\n"
			 exit 1
		else
			# defaults
			TRACEASNPATH=true
			DETAILED_TRACE=false
			ENABLE_ORGSEARCH=true
			userinput="$@"
		fi
		;;
esac

# Check prerequisites
# TODO: consider switching to DNS lookups (ie dig instead of whois) to improve speed
if [ -z "$(command -v coproc)" ]; then
	echo -e "\n${red}ERROR: ${white}program '${red}coproc${white}' not found on this system.\n${white}This script requires BASH v4.2+ to run.\nIf you're on MacOS please install an updated version with:" \
		"\n\n${green}brew install bash${white}\n"
	exit 1
fi
if [ -z "$(command -v whois)" ]; then
	echo -e "\n${red}ERROR: ${white}program '${red}whois${white}' not found on this system.\nPlease install it (for example with ${green}sudo apt install whois${white} on Debian-based linux distributions)\n"
	exit 1
fi
if [ -z "$(command -v host)" ]; then
	echo -e "\n${red}ERROR: ${white}program '${red}host${white}' not found on this system.\nPlease install it (for example with ${green}sudo apt install bind9-host${white} on Debian-based linux distributions)\n"
	exit 1
fi
if [ -z "$(command -v curl)" ]; then
	echo -e "\n${red}ERROR: ${white}program '${red}curl${white}' not found on this system.\nPlease install it (for example with ${green}sudo apt install curl${white} on Debian-based linux distributions)\n"
	exit 1
fi
if [ $TRACEASNPATH = true ] && [ -z "$(command -v mtr)" ]; then
	echo -e "\n${yellow}WARNING: ${white}program '${red}mtr${white}' not found on this system.\nPlease install it (for example with ${green}sudo apt install mtr-tiny${white}" \
		"\non Debian-based linux distributions) to enable AS path tracing"
	TRACEASNPATH=false
fi
if [ -z "$(command -v jq)" ]; then
	# won't be able to parse data from RIPEstat and IP reputation data, but no hard fail
	echo -e "\n${yellow}WARNING: ${white}program '${red}jq${white}' not found on this system.\n\nPlease install it (for example with ${green}sudo apt install jq${white}" \
		"on Debian-based linux distributions)\nto enable IP reputation and RIPEstat BGP info lookups${default}"
	HAVE_JQ=false
else
	HAVE_JQ=true
fi
if [ -z "$(command -v ipcalc)" ]; then
	# won't be able to aggregate netblocks into CIDR prefixes during Search by Organization, but no hard fail
	HAVE_IPCALC=false
else
	HAVE_IPCALC=true
fi

BoxHeader "ASN lookup for $userinput"
input=$(echo "$userinput" | sed 's/\/.*//g' | grep -Eo "$ipv4v6regex")
if [ -z "$input" ]; then
	# Input is not an IP Address. Check if it is a number (ASN)
	asn=$(echo "$userinput" | sed 's/[a|A][s|S]//g' | grep -E "^[0-9]*$")
	if [ -z "$asn" ]; then
		# Input is not an ASN either. See if it's a hostname (includes at least one dot)
		if echo "$userinput" | grep -q "\."; then
			echo -e -n "\n${blue}- Resolving \"$userinput\"... "
			ip=$(ResolveHostnameToIPList "$userinput")
			if [ -z "$ip" ]; then
				echo ""
				PrintErrorAndExit "Error: unable to resolve hostname"
			fi
			numips=$(echo "$ip" | wc -l)
			[[ $numips = 1 ]] && s="" || s="es"
			echo -e "${blue}$numips IP address$s found:\n"
			# grab the longest IP to properly size output padding
			longest=0
			for singleip in $ip; do
				[[ ${#singleip} -gt $longest ]] && longest=${#singleip}
			done
			(( longest++ ))
			# output actual results
			ip_to_trace=""
			for singleip in $ip; do
				LookupASNAndRouteFromIP "$singleip"
				WhoisIP "$singleip"
				# save the first IP from the dns lookup result
				[[ -z "$ip_to_trace" ]] && ip_to_trace="$singleip"
			done
			# Check if AS path tracing is requested
			if [ $TRACEASNPATH = true ]; then
				# in case of multiple IPs (DNS RR), trace the first one
				TraceASPath "$ip_to_trace"
			fi
			tput sgr0
			echo ""
			exit 0
		else
			# not an IP, not an ASN, not a hostname. Consider it an Organization name unless a cmdline option was specified
			[[ -z "$ENABLE_ORGSEARCH" ]] && PrintErrorAndExit "Error: Search by ORGANIZATION requires no command line switches"
			ORG_FILTER=false
			declare -a orgfilters_array
			declare -a excl_orgfilters_array
			SearchByOrg "$userinput"
		fi
	else
		# Input is an ASN
		WhoisASN "$asn"
		if [ -z "$found_asname" ]; then
			PrintErrorAndExit "Error: no data found for AS${asn}"
		fi
		echo -e "\n${bluebg} AS Number ──────>${default} ${red}${asn}"
		echo -e "${bluebg} AS Name ────────>${default} ${green}${found_asname}"
		echo -e "${bluebg} Organization ───>${default} ${yellow}${found_org}"
		echo -e "${bluebg} AS Reg. date ───>${default} ${white}${found_createdate}\n"
		if [ "$HAVE_JQ" = true ]; then
			QueryRipestat "${asn}"
			if [ -n "$ripestat_data" ]; then
				echo -e "${bluebg} IPv4 Prefixes ──>${default} ${green}${ripestat_ipv4}"
				echo -e "${bluebg} IPv6 Prefixes ──>${default} ${yellow}${ripestat_ipv6}"
				echo -e "${bluebg} BGP Neighbours ─>${default} ${blue}${ripestat_bgp}${default}\n"
			fi
		fi
		tput sgr0
		echo ""
		exit 0
	fi
else
	# Input is an IP address
	# Read Auth0 Signals (IP reputation API) token from file
	if [ "$HAVE_JQ" = true ]; then
		REPUTATION_LOOKUP=true
		SIGNALS_TOKEN=""
		if [ -r "$SIGNALS_TOKEN_FILENAME" ]; then
			SIGNALS_TOKEN=$(tr -d ' \n\r\t' < "$SIGNALS_TOKEN_FILENAME")
		fi
	fi
	# Check if IP reputation lookup is enabled
	if [ "$REPUTATION_LOOKUP" = true ]; then
		if [ -z "$SIGNALS_TOKEN" ]; then
			# warn the user about the limits of anonymous Signals queries
			echo -en "\n${yellow}────────────────────────────────────────────────────────────\n\t\t\tWARNING${default}" \
				"\n\nNo Auth0 Signals token found, so running anonymously.\n\nConsider registering at" \
				"${blue}https://auth0.com/signals/api/signup${default}\nto obtain a free token and increase" \
				"your IP reputation\nquery limit from 100 hits/day to 40000 hits/day.\n\nAfter getting your API token, copy and paste it inside" \
				"\n${green}$SIGNALS_TOKEN_FILENAME${default} and it will be used automatically." \
				"\n${yellow}────────────────────────────────────────────────────────────${default}\n"
		fi
	fi
	echo ""
	# Perform IP lookup
	LookupASNAndRouteFromIP "$input"
	(( longest=${#input}+1 ))
	WhoisIP "$input"
	# Perform reputation lookup if requested
	[[ "$REPUTATION_LOOKUP" = true ]] && ReputationLookup "$input"
	# Perform AS path tracing if requested
	[[ "$TRACEASNPATH" = true ]] && TraceASPath "$input"
	tput sgr0
	echo ""
	exit 0
fi
