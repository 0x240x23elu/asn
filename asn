#!/usr/bin/env bash

########################################################################################
# -----------------------------------------------------------------------------------
#          ASN / IPv4 / IPv6 / Prefix / AS Path / Organization lookup tool
#
#               Project homepage: https://github.com/nitefood/asn
# -----------------------------------------------------------------------------------
#
# Usage:
#
#  (Launch the script without parameters or visit the project's homepage for usage info)
#
########################################################################################

WhoisASN(){
	found_asname=$(host -t TXT "AS${1}.asn.cymru.com" | grep -v "NXDOMAIN" | awk -F'|' 'NR==1{print substr($NF,2,length($NF)-2)}')
	if [ -n "$found_asname" ]; then
		pwhois_asn_info=$(whois -h whois.pwhois.org "registry source-as=$1" | grep -E "^Org-Name:|^Create-Date:")
		found_org=$(echo -e "$pwhois_asn_info" | grep -E "^Org-Name:" | cut -d ':' -f 2 | sed 's/^[ \t]*//')
		[[ -z "$found_org" ]] && found_org="N/A"
		pwhois_createdate=$(echo -e "$pwhois_asn_info" | grep -E "^Create-Date:" | cut -d ':' -f 2- | sed 's/^[ \t]*//')
		[[ -z "$pwhois_createdate" ]] && found_createdate="N/A" || found_createdate=$(date -d "$pwhois_createdate" "+%Y-%m-%d %H:%M:%S")
	fi
}

QueryRipestat(){
	StatusbarMessage "Retrieving BGP data for AS$1 ($found_asname)"
	# BGP routing stats
	ripestat_routing_data=$(curl -s "https://stat.ripe.net/data/routing-status/data.json?resource=AS$1&sourceapp=nitefood-asn")
	if [ -n "$ripestat_routing_data" ]; then
		ripestat_ipv4=$(echo -e "$ripestat_routing_data" | jq -r '.data.announced_space.v4.prefixes')
		ripestat_ipv6=$(echo -e "$ripestat_routing_data" | jq -r '.data.announced_space.v6.prefixes')
		ripestat_bgp=$(echo -e "$ripestat_routing_data" | jq -r '.data.observed_neighbours')
	fi
	# BGP neighbours list
	StatusbarMessage "Retrieving peering data for AS$1 ($found_asname)"
	ripestat_neighbours_data=$(curl -s "https://stat.ripe.net/data/asn-neighbours/data.json?resource=AS$1&sourceapp=nitefood-asn")
	upstream_peers=$(echo -e "$ripestat_neighbours_data" 	| jq -r '.data.neighbours | sort_by(.power) | reverse | .[] | select (.type=="left") | .asn')
	downstream_peers=$(echo -e "$ripestat_neighbours_data" 	| jq -r '.data.neighbours | sort_by(.power) | reverse | .[] | select (.type=="right") | .asn')
	uncertain_peers=$(echo -e "$ripestat_neighbours_data" 	| jq -r '.data.neighbours | sort_by(.power) | reverse | .[] | select (.type=="uncertain") | .asn')

	RESOLVE_COUNT=20
	OUTPUT_PEERS_PER_LINE=4

	# resolve AS names of the first n upstreams
	upstream_peercount=$(echo "$upstream_peers" | wc -l)
	resolved_upstream_peers=""
	count=0
	for peer in $(echo -e "$upstream_peers" | head -n $RESOLVE_COUNT); do
		(( count++ ))
		peername=$(curl -s "https://stat.ripe.net/data/as-overview/data.json?resource=AS$peer&sourceapp=nitefood-asn" | jq -r '.data.holder' | sed 's/ - .*//' )
		resolved_upstream_peers+="${greenbg} $peername ($peer) ${default} "
		[[ $(( count % OUTPUT_PEERS_PER_LINE )) -eq 0 ]] && resolved_upstream_peers+="\n"
	done
	# and add the remaining ones as AS numbers only
	unresolved_peercount=$(( upstream_peercount - RESOLVE_COUNT ))
	if [ "$unresolved_peercount" -ge 1 ]; then
		resolved_upstream_peers+="and more: "
		for peer in $(echo -e "$upstream_peers" | tail -n $unresolved_peercount ); do
			resolved_upstream_peers+="${green}${peer}${default} "
		done
	fi
	upstream_peers="$resolved_upstream_peers"

	# resolve AS names of the first n downstreams
	downstream_peercount=$(echo "$downstream_peers" | wc -l)
	resolved_downstream_peers=""
	count=0
	for peer in $(echo -e "$downstream_peers" | head -n $RESOLVE_COUNT); do
		(( count++ ))
		peername=$(curl -s "https://stat.ripe.net/data/as-overview/data.json?resource=AS$peer&sourceapp=nitefood-asn" | jq -r '.data.holder' | sed 's/ - .*//' )
		resolved_downstream_peers+="${yellowbg} $peername ($peer) ${default} "
		[[ $(( count % OUTPUT_PEERS_PER_LINE )) -eq 0 ]] && resolved_downstream_peers+="\n"
	done
	# and add the remaining ones as AS numbers only
	unresolved_peercount=$(( downstream_peercount - RESOLVE_COUNT ))
	if [ "$unresolved_peercount" -ge 1 ]; then
		resolved_downstream_peers+="and more: "
		for peer in $(echo -e "$downstream_peers" | tail -n $unresolved_peercount ); do
			resolved_downstream_peers+="${yellow}${peer}${default} "
		done
	fi
	downstream_peers="$resolved_downstream_peers"

	# resolve AS names of the first n uncertains
	uncertain_peercount=$(echo "$uncertain_peers" | wc -l)
	resolved_uncertain_peers=""
	count=0
	for peer in $(echo -e "$uncertain_peers" | head -n $RESOLVE_COUNT); do
		(( count++ ))
		peername=$(curl -s "https://stat.ripe.net/data/as-overview/data.json?resource=AS$peer&sourceapp=nitefood-asn" | jq -r '.data.holder' | sed 's/ - .*//' )
		resolved_uncertain_peers+="${lightgreybg} $peername ($peer) ${default} "
		[[ $(( count % OUTPUT_PEERS_PER_LINE )) -eq 0 ]] && resolved_uncertain_peers+="\n"
	done
	# and add the remaining ones as AS numbers only
	unresolved_peercount=$(( uncertain_peercount - RESOLVE_COUNT ))
	if [ "$unresolved_peercount" -ge 1 ]; then
		resolved_uncertain_peers+="and more: "
		for peer in $(echo -e "$uncertain_peers" | tail -n $unresolved_peercount ); do
			resolved_uncertain_peers+="${white}${peer}${default} "
		done
	fi
	uncertain_peers="$resolved_uncertain_peers"

	StatusbarMessage "Retrieving prefix allocations and announcements for AS$1 ($found_asname)"
	ipv4_inetnums=""
	ipv6_inetnums=""
	for prefix in $(curl -s "https://stat.ripe.net/data/announced-prefixes/data.json?resource=$1&sourceapp=nitefood-asn" | jq -r '.data.prefixes | .[] | .prefix'); do
		if [[ "$prefix" == *':'* ]]; then
			inet6nums=$(whois -h whois.ripe.net -- "-T inet6num -K -L --resource $prefix" | \
							grep -m2 inet6num | cut -d ':' -f 2- | sed 's/^[ \t]*//')
			for inet6num in $inet6nums; do
				# exclude RIR supernets
				prefix_size=$(echo "$inet6num" | cut -d '/' -f 2)
				[[ "$prefix_size" -lt 29 ]] && continue || ipv6_inetnums+="${inet6num}\n"
			done
		else
			ipv4_inetnums+=$(whois -h whois.ripe.net -- "-T inetnum -K -L --resource  $prefix" | \
							grep -m1 inetnum | cut -d ':' -f 2 | sed 's/^[ \t]*//' | xargs ipcalc -r | grep -v "deaggregate")
			ipv4_inetnums+="\n"
		fi
	done

	[[ -n "$ipv4_inetnums" ]] && ipv4_inetnums=$(echo -e "$ipv4_inetnums" | sort -u)
	[[ -n "$ipv6_inetnums" ]] && ipv6_inetnums=$(echo -e "$ipv6_inetnums" | sort -u)
	StatusbarMessage ""
}

RIPESuggestASN(){
	TRIM_WHITESPACES=false
	input="$1"
	while true; do
		StatusbarMessage "Retrieving suggested ASNs for ${bluebg}${input}${lightgreybg}"
		ripe_suggest_output=$(curl -s "https://stat.ripe.net/data/searchcomplete/data.json?resource=${input}&sourceapp=nitefood-asn" | \
								jq -r '.data.categories | .[] | select ( .category == "ASNs" ) | .suggestions[]')
		StatusbarMessage ""
		if [ -n "$ripe_suggest_output" ]; then
			found_suggestions=$(echo -e "$ripe_suggest_output" | jq -r '.description' | sort -u)
			for suggestion in $found_suggestions; do
				echo -e "\n${green}$suggestion${default}"
				for suggestion_asn in $(echo -e "$ripe_suggest_output" | jq -r 'select (.description=="'"$suggestion"'") | .value'); do
					echo -e "\t${yellow}$suggestion_asn${default}"
				done
			done
			echo ""
			return
		elif [ "$TRIM_WHITESPACES" = false ]; then
			TRIM_WHITESPACES=true
			oldinput="$input"
			# shellcheck disable=SC2001
			input=$(echo "$oldinput" | sed 's/[ \t]*//g')
			if [ "$input" = "$oldinput" ]; then
				echo -e "\n${redbg}No suggestions found${default}\n"
				return
			else
				continue
			fi
		else
			echo -e "\n${redbg}No suggestions found${default}\n"
			return
		fi
	done
}

WhoisIP(){
	# $1: (mandatory) IP to lookup
	# $2: (optional) if set to anything, only perform a generic whois lookup (skip pWhois/RPKI/IXP lookups)
	GENERIC_WHOIS_LOOKUP_ONLY=false
	[[ "$#" -gt 1 ]] && GENERIC_WHOIS_LOOKUP_ONLY=true
	full_whois_data=$(whois "$1")
	network_whois_data=$(echo -e "$full_whois_data" | grep -i -E "^netname:|^orgname:|^org-name:|^owner:|^descr:|^country:")
	# Check if input is a bogon address
	if [ "$IS_BOGON" = false ]; then
		if [ "$GENERIC_WHOIS_LOOKUP_ONLY" = false ]; then
			abuse_whois_data=$(echo -e "$full_whois_data" | grep -E "^OrgAbuseEmail:|^abuse-c:|^% Abuse|^abuse-mailbox:")
			hostname=$(RdnsLookup "$1")
			abusecontacts=$(AbuseLookup "$abuse_whois_data")
			[[ -z "$hostname" ]] && hostname="-"
		fi
		if [ "$UNANNOUNCED_PREFIX" = false ] && [ "$GENERIC_WHOIS_LOOKUP_ONLY" = false ]; then
			# Prefix found in the Team Cymru DB
			PwhoisLookup "$1"
		else
			# No data in the Team Cymru DB for this IP (unannounced prefix), or pWhois being skipped
			if [ "$GENERIC_WHOIS_LOOKUP_ONLY" = false ]; then
				[[ -z "$network_whois_data" ]] && PrintErrorAndExit "Error: no data found for $input"
				found_asn="N/A (address not announced)"
				found_asname=""
			fi
			IPGeoRepLookup "$1"
			# check if it's an IXP, otherwise fall back to generic whois
			[[ "$GENERIC_WHOIS_LOOKUP_ONLY" = false ]] && IsIXP "$1" || ixp_data=""; ixp_geo=""
			if [ -n "$ixp_data" ]; then
				pwhois_org="${bluebg} IXP ${default} ${blue}${ixp_data}${default}"
				ip_type_data=" ${yellowbg} Internet Exchange ${default}"
			else
				pwhois_org=$(echo -e "$network_whois_data" | grep -i -E "^orgname:|^org-name:|^owner:" | cut -d ':' -f 2 | sed 's/^[ \t]*//' | while read -r line; do echo -n "$line / "; done | sed 's/ \/ $//')
			fi
			[[ -z "$pwhois_org" ]] && pwhois_org="N/A"
			found_route=$(echo -e "$network_whois_data" | grep -i -m2 -E "^descr:" | cut -d ':' -f 2 | sed 's/^[ \t]*//' | while read -r line; do if [ -n "$line" ]; then echo -n "$line / "; fi; done | sed 's/ \/ $//')
			[[ -z "$found_route" ]] && found_route="N/A"
			pwhois_net=$(echo -e "$network_whois_data" | grep -i -E "^netname:" | cut -d ':' -f 2 | sed 's/^[ \t]*//' | while read -r line; do echo -n "$line / "; done | sed 's/ \/ $//')
			[[ -z "$pwhois_net" ]] && pwhois_net="N/A"
			if [ -n "$ixp_geo" ]; then
				pwhois_geo="$ixp_geo"
			elif [ -n "$ip_geo_data" ]; then
				pwhois_geo="$ip_geo_data"
			else
				pwhois_geo=$(echo -e "$network_whois_data" | grep -m1 -i -E "^country:" | cut -d ':' -f 2 | sed 's/^[ \t]*//')
			fi
			[[ -z "$pwhois_geo" ]] && pwhois_geo="N/A"
		fi
	else
		# bogon address, skip lookups
		hostname="-"
		found_asn="-"
		pwhois_org="IANA"
		found_route="N/A"
		abusecontacts="-"
		pwhois_net=$(echo -e "$network_whois_data" | grep -i -E "^netname:" | cut -d ':' -f 2 | sed 's/^[ \t]*//' | while read -r line; do echo -n "$line / "; done | sed 's/ \/ $//')
		found_asname=""
		ip_type_data=" $bogon_tag"
		pwhois_geo="-"
		ip_rep_data="-"
	fi

	indent=$(( longest+4 ))
	if [ -n "$found_asname" ]; then
		output_asname="${green}($found_asname)"
	else
		output_asname=""
	fi
	rpki_output=""
	if [ "$UNANNOUNCED_PREFIX" = false ] && [ "$GENERIC_WHOIS_LOOKUP_ONLY" = false ]; then
		# we skip RPKI lookup in both cases because if SKIP_WHOIS=true then we're being
		# called from TraceASPath, and RPKI lookup will be performed there subsequently
		StatusbarMessage "Checking RPKI validity for ${bluebg}AS${found_asn}${lightgreybg} and prefix ${bluebg}${found_route}${lightgreybg}"
		RPKILookup "$found_asn" "$found_route"
		StatusbarMessage ""
		echo ""
	elif [ "$IS_BOGON" = false ]; then
		rpki_output="${red}N/A (address not announced)${default}"
	else
		rpki_output="-"
	fi

	printf "${white}%${longest}s${default} ┌${bluebg}PTR${default} %s\n" "$1" "$hostname"
	printf "${white}%${indent}s${bluebg}ASN${default} ${red}%s %s${default}\n" "├" "$found_asn" "$output_asname"
	printf "${white}%${indent}s${bluebg}ORG${default} ${green}%s${default}\n" "├" "$pwhois_org"
	printf "${white}%${indent}s${bluebg}NET${default} ${yellow}%s (%s)${default}\n" "├" "$found_route" "$pwhois_net"
	printf "${white}%${indent}s${bluebg}ABU${default} ${blue}%s${default}\n" "├" "$abusecontacts"
	printf "${white}%${indent}s${bluebg}ROA${default} %s\n" "├" "$rpki_output"
	[[ -n "$ip_type_data" ]] && printf "${white}%${indent}s${bluebg}TYP${default}%s\n" "├" "$ip_type_data"
	printf "${white}%${indent}s${bluebg}GEO${default} ${magenta}%s${default}\n" "├" "$pwhois_geo"
}

IsBogon(){
	bogon_tag=""
	IS_BOGON=false
	# Bogon regex patterns
	localhostregex='(^127\.)' # RFC 1122 localhost
	thisnetregex='(^0\.)' # RFC 1122 'this' network
	privateregex='(^192\.168\.)|(^10\.)|(^172\.1[6-9]\.)|(^172\.2[0-9]\.)|(^172\.3[0-1]\.)|(^::1$)|(^[fF][cCdD])' # RFC 1918 private space - cheers https://stackoverflow.com/a/11327345/5377165
	cgnregex='(^100\.6[4-9]\.)|(^100\.[7-9][0-9]\.)|(^100\.1[0-1][0-9]\.)|(^100\.12[0-7]\.)' # RFC 6598 Carrier grade nat space
	llregex='(^169\.254\.)' # RFC 3927 link local
	ietfprotoregex='(^192\.0\.0\.)' # IETF protocol assignments
	testnetregex='(^192\.0\.2\.)|(^198\.51\.100\.)|(^203\.0\.113\.)' # RFC 5737 TEST-NET
	benchmarkregex='(^192\.1[8-9]\.)' # RFC 2544 Network interconnect device benchmark testing
	sixtofouranycast='(^192\.88\.99\.)' # RFC 7526 6to4 anycast relay
	multicastregex='(^22[4-9]\.)|(^23[0-9]\.)' # Multicast
	reservedregex='(^24[0-9]\.)|(^25[0-5]\.)' # Reserved for future use/limited broadcast (255.255.255.255)

	if [[ "$1" =~ $localhostregex ]]; then
		bogon_tag="rfc1122 (Localhost)"
		TRACEASNPATH=false
	elif [[ "$1" =~ $thisnetregex ]]; then
		bogon_tag="rfc1122 ('this' network)"
		TRACEASNPATH=false
	elif [[ "$1" =~ $privateregex ]]; then
		bogon_tag="rfc1918 (Private Space)"
	elif [[ "$1" =~ $cgnregex ]]; then
		bogon_tag="rfc6598 (CGN Space)"
	elif [[ "$1" =~ $llregex ]]; then
		bogon_tag="rfc3927 (Link-Local)"
	elif [[ "$1" =~ $ietfprotoregex ]]; then
		bogon_tag="(Reserved for IETF protocol assignments)"
	elif [[ "$1" =~ $testnetregex ]]; then
		bogon_tag="rfc5737 (Reserved for Test Networks)"
	elif [[ "$1" =~ $benchmarkregex ]]; then
		bogon_tag="rfc2544 (Reserved for Network device benchmark testing)"
	elif [[ "$1" =~ $sixtofouranycast ]]; then
		bogon_tag="rfc7526 (6to4 anycast relay)"
	elif [[ "$1" =~ $multicastregex ]]; then
		bogon_tag="(Multicast Address)"
		TRACEASNPATH=false
	elif [[ "$1" =~ $reservedregex ]]; then
		bogon_tag="(Reserved Address)"
		TRACEASNPATH=false
	fi
	if [ -n "$bogon_tag" ]; then
		IS_BOGON=true
		bogon_tag="${yellowbg} BOGON ${default} ${bogon_tag}"
	fi
}

LookupASNAndRouteFromIP(){
	found_asn=""
	found_route=""
	found_asname=""
	IsBogon "$1"
	if [ "$IS_BOGON" = false ]; then
		if echo "$1" | grep -q ':'; then
			# whois query for IPv6 addresses
			output=$(whois -h whois.cymru.com " -f -p -u $1" | sed 's/\ *|\ */|/g')
			found_asn=$(echo "$output" | awk -F'[|]' 'NR==1{print $1}')
			if [ "$found_asn" = "NA" ]; then
				# Team Cymru has no data for this IPv6. Inform WhoisIP() that we will have to fall back to a generic whois lookup.
				found_asn=""
				UNANNOUNCED_PREFIX=true
			else
				found_asname=$(echo "$output" | awk -F'[|]' 'NR==1{print $4}')
				found_route=$(echo "$output" | awk -F'[|]' 'NR==1{print $3}')
				UNANNOUNCED_PREFIX=false
			fi
		else
			# DNS query (faster) for IPv4 addresses
			rev=$(echo "$1" | awk -F'.' '{printf $4 "." $3 "." $2 "." $1}')
			output=$(host -t TXT "$rev.origin.asn.cymru.com" | awk -F'"' 'NR==1{print $2}' | sed 's/\ *|\ */|/g')
			found_asn=$(echo "$output" | awk -F'[|]' 'NR==1{print $1}' | cut -d ' ' -f 1) # final cut gets first origin AS only if cymru has multiple
			if [ -n "$found_asn" ]; then
				found_asname=$(host -t TXT "AS$found_asn.asn.cymru.com" | grep -v "NXDOMAIN" | awk -F'|' 'NR==1{print substr($NF,2,length($NF)-2)}')
				found_route=$(echo "$output" | awk -F'[|]' 'NR==1{print $2}')
				UNANNOUNCED_PREFIX=false
			else
				# Team Cymru has no data for this IPv4. Inform WhoisIP() that we will have to fall back to a generic whois lookup.
				UNANNOUNCED_PREFIX=true
			fi
		fi
	else
		# bogon address, consider it unannounced
		UNANNOUNCED_PREFIX=true
	fi
}

ResolveHostnameToIPList(){
	raw_host_output=$(host "$1" 2>/dev/null)
	if echo -e "$raw_host_output" | grep -q "mail is handled"; then
		host_output=$(echo "$raw_host_output" | grep -B100 -A0 -m1 "mail is handled" | sed '$d')
	else
		host_output="$raw_host_output"
	fi
	ip=$(echo "$host_output" | grep -Eo "$ipv4v6regex")
	echo -e "$ip\n"
}

PrintUsage(){
	programname=$(basename "$0")
	BoxHeader "ASN / RPKI validity / BGP stats / IPv4v6 / Prefix / ASPath / Organization / IP reputation lookup tool"
	echo -e "\nUsage:\n\n  $programname ${green}[OPTIONS] ${blue}<TARGET>${default}\n\nOptions:" \
			"\n\n  ${green}-d, --detailed\n\t${default}Output detailed hop info during the AS path trace to the ${blue}TARGET${default}" \
			"\n\t(This option also enables RPKI validation/BGP hijacking detection for every hop)" \
			"\n\n  ${green}-n, --notrace\n\t${default}Disable tracing the AS path to the ${blue}TARGET${default}" \
			"\n\n  ${green}-s, --suggest\n\t${default}Lookup AS names and numbers matching ${blue}TARGET${default}" \
			"\n\n  ${green}-o, --organization\n\t${default}Force ${blue}TARGET${default} to be treated as an Organization Name" \
			"\n\nSupported targets:" \
			"\n\n  ${blue}<AS Number>${default}\n\tLookup matching and BGP announcements/neighbours data." \
			"\n\t(Supports \"as123\" and \"123\" formats - case insensitive)" \
			"\n\n  ${blue}<IPv4/IPv6>${default}\n\tLookup matching route(4/6), IP reputation and ASN data" \
			"\n\n  ${blue}<Prefix>${default}\n\tLookup matching ASN data" \
			"\n\n  ${blue}<host.name.tld>${default}\n\tLookup matching IP, route and ASN data. Supports multiple IPs - e.g. DNS RR" \
			"\n\n  ${blue}<Organization Name>${default}\n\tSearch by company name and lookup network ranges exported by (or related to) the company" \
			"\n\n\nProject homepage: ${yellow}https://github.com/nitefood/asn${default}\n"
}

PwhoisLookup(){
	StatusbarMessage "Collecting pWhois data"
	pwhois_output=$(whois -h whois.pwhois.org "$1")
	StatusbarMessage ""
	if echo "$pwhois_output" | grep -vq "That IP address doesn't appear"; then
		# pwhois_asn=$(echo "$pwhois_output" | grep -E "^Origin-AS" | cut -d ':' -f 2 | sed 's/^ //')
		# pwhois_prefix=$(echo "$pwhois_output" | grep -E "^Prefix" | cut -d ':' -f 2 | sed 's/^ //')
		pwhois_asorg=$(echo "$pwhois_output" | grep -E "^AS-Org-Name" | cut -d ':' -f 2 | sed 's/^ //')
		# group all "Org-Name" fields on a single line
		pwhois_org=$(echo "$pwhois_output" | grep -E "^Org-Name" | cut -d ':' -f 2 | sed 's/^[ \t]*//g' | while read -r line; do echo -n "$line / "; done | sed 's/ \/ $//')
		pwhois_net=$(echo "$pwhois_output" | grep -E "^Net-Name" | cut -d ':' -f 2 | sed 's/^ //')
		# if pWhois' Net-Name=Org-Name, then it's more useful to use AS-Org-Name instead of Org-Name (unless AS-Org-Name is empty)
		if [ -n "$pwhois_asorg" ] && [ "$pwhois_net" = "$pwhois_org" ]; then
			pwhois_org="$pwhois_asorg"
		fi
		IPGeoRepLookup "$1"
		pwhois_geo="$ip_geo_data"
		if [ -z "$ip_geo_data" ]; then
			if echo "$pwhois_output" | grep -q -E "^Geo-"; then
				# use "Geo-" fields in pWhois output
				cityfield="Geo-City"
				regionfield="Geo-Region"
				ccfield="Geo-CC"
			else
				cityfield="City"
				regionfield="Region"
				ccfield="Country-Code"
			fi
			pwhois_city=$(echo "$pwhois_output" | grep -m1 -E "^${cityfield}" | cut -d ':' -f 2 | sed 's/^ //')
			pwhois_region=$(echo "$pwhois_output" | grep -m1 -E "^${regionfield}" | cut -d ':' -f 2 | sed 's/^ //')
			pwhois_cc=$(echo "$pwhois_output" | grep -m1 -E "^${ccfield}" | cut -d ':' -f 2 | sed 's/^ //')
			if [ "$pwhois_city" = "NULL" ] || [ "$pwhois_region" = "NULL" ]; then
				pwhois_geo="$pwhois_cc"
			else
				pwhois_geo="$pwhois_city, $pwhois_region ($pwhois_cc)"
			fi
		fi
	else
		pwhois_output="";
	fi
}

RdnsLookup(){
	# reverse DNS (PTR) lookup.
	# get first lookup result only (in case of multiple PTR records) and remove trailing dot and CR (Cygwin) from hostname
	rdns=$(host "$1" | awk 'NR==1{sub(/\.\r?$/, "", $NF); print $NF}')
	if echo "$rdns" | grep -E -q "NXDOMAIN|SERVFAIL|REFUSED|^record$"; then rdns=""; fi
	echo "$rdns"
}

AbuseLookup(){
	abuselist=""
	for abusecontact in $(echo -e "$1" | grep -E "^OrgAbuseEmail:|^abuse-c:|^% Abuse|^abuse-mailbox:" | awk '{print $NF}' | tr -d \'); do
		if echo "$abusecontact" | grep -vq '@'; then
			# $abusecontact is not an email, try a whois lookup (it should be a handle)
			resolvedabuse=$(whois "$abusecontact" | grep -E -i "^abuse-mailbox:" | awk '{print $2}' | tr -d \')
			if [ -z "$resolvedabuse" ]; then
				# whois couldn't resolve the abuse handle. Try identifying the
				# original answering whois server and forcing a lookup on the same server
				original_whois_server=$(echo -e "$full_whois_data" | grep -E "^%.*whois\..*$" | awk 'NR==1 {print $NF}' | tr -d '[]')
				if [ -n "$original_whois_server" ]; then
					# original whois server found, try manually querying it with an extended set of grep patterns
					resolvedabuse=$(whois -h "$original_whois_server" "$abusecontact" | grep -E -m1 -i "^abuse-mailbox:|^e-mail:" | awk '{print $2}' | tr -d \')
				fi
			fi
			[[ -n "$resolvedabuse" ]] && abusecontact="$resolvedabuse"
		fi
		[[ -n "$abuselist" ]] && abuselist+="\n"
		abuselist+="$abusecontact"
	done

	if [ -n "$abuselist" ]; then
		echo -e "$abuselist" | tr " " "\n" | sort -u | while read -r line; do echo -n "$line / "; done | sed 's/ \/ $//'
	else
		echo "-"
	fi
}

HopPrint(){
	StatusbarMessage ""
	echo -e "$@"
	StatusbarMessage "Analyzing collected trace output to ${bluebg}${host_to_trace}${lightgreybg}"
}

TraceASPath(){
	starttime=$(date +%s)
	host_to_trace="$1"
	mtr_rounds=5
	border_color=$'\e[38;5;109m'
	# attepmt to be as responsive as possible
	# ideal output width : 150 (size of headers in normal traces)
	# ideal border width : 100 (used in detailed traces only)
	if [ "$terminal_width" -ge 153 ]; then
		output_width=150
		border_width=100
	elif [ "$terminal_width" -ge 103 ]; then
		output_width=$((terminal_width-3))
		border_width=100
	else
		output_width=$((terminal_width-3))
		border_width=$((terminal_width-3))
	fi

	WhatIsMyIP
	if [ "$DETAILED_TRACE" = true ]; then
		headermsg="Detailed trace to $userinput"
	else
		headermsg="Trace to $userinput"
	fi
	BoxHeader "$headermsg"
	# check if we're trying to trace an IPv6 from an IPv4-only box
	echo "$host_to_trace" | grep -q ':' && is_ipv6=true || is_ipv6=false
	if [ "$is_ipv6" = true ] && [ "$HAVE_IPV6" = false ]; then
		PrintErrorAndExit "Error: cannot trace an IPv6 from this IPv4-only host!"
	fi
	echo ""
	StatusbarMessage "Collecting trace data to ${bluebg}${host_to_trace}${lightgreybg}"

	# start the mtr trace
	mtr_output=$(mtr -C -n -c"$mtr_rounds" "$host_to_trace" | tail -n +2)
	declare -a tracehops_array
	declare -a aspath_array
	# initialize the aspath array with our source AS
	# TODO: improve local WAN IPv6 ASN lookup (Cymru and pWhois sometimes fail to correctly retrieve matching prefix. Consider RIPEstat/direct whois?)
	LookupASNAndRouteFromIP "$local_wanip"
	if [ -z "$found_asn" ]; then
		found_asn="XXX"
		found_asname="(Unknown)"
	fi
	aspath_entry=$(printf "${red}%-6s ${green}%s${default}" "$found_asn" "$(echo "$found_asname" | cut -d ',' -f 1)" )
	aspath_array+=("$aspath_entry")

	# mtr finished, analyze and output results
	# print trace headers (only non-detailed trace)
	if [ "$DETAILED_TRACE" = false ]; then
		HopPrint "$(printf "${lightgreybg}%4s %-$((output_width-61))s %7s %13s     %s                ${default}" "Hop" "IP Address" "Loss%" "Ping avg" "AS Information")"
	fi
	LAST_HOP=false
	ROUTING_LOOP=false

	# parse mtr output (csv)
	hop_num=0
	while true; do
		((hop_num++))
		IFS=',' read -ra cur_hop_data <<< "$(echo "$mtr_output" | head -n "$hop_num" | tail -n 1)"
		mtr_hopnum=${cur_hop_data[4]}
		[[ "$hop_num" -gt "$mtr_hopnum" ]] && break # we're past the last trace hop, quit the loop
		hop_ip=${cur_hop_data[5]}
		hop_loss=${cur_hop_data[6]%.*}
		hop_ping=$(echo "${cur_hop_data[10]}" | awk '{ printf ("%.1f\n", $1) }')
		if [ "$hop_loss" -ne 0 ]; then
			# color packet loss yellow if between 1% and 50%, or red if > 50%
			[[ "$hop_loss" -le 50 ]] && loss_color="$lightyellow" || loss_color="$lightred"
			if [ "$DETAILED_TRACE" = false ]; then
				hop_loss=$(printf "${loss_color}%5s" "$hop_loss") # packet loss position in normal path trace (spacing to fit the column alignment)
			else
				hop_loss="${loss_color}${hop_loss}" # packet loss position in detailed path trace (no spacing)
			fi
		fi
		tracehops_array["$hop_num"]="$hop_ip"
		ixp_tag=""
		hop_asn=""
		if [ "$hop_ip" = "???" ]; then
			# print no reply hop info
			if [ "$DETAILED_TRACE" = true ]; then
				trailing_line=$(printf '%.0s═' $(seq $((border_width-9-${#hop_ip}))) )
				hop_output="$(printf "${border_color}╔═[${default}%3s. %s ${border_color}]%s╗${default}\n" "$hop_num" "$hop_ip" "$trailing_line")"
				hop_output+="\n        ├${bluebg}RTT${default} ${white}* (No reply)${default}\n"
				hop_output+="        └${bluebg}LOS${default} ${hop_loss}%${default} packet loss\n"
			else
				hop_output="$(printf "%3s. %-$((output_width-60))s %6s${default} %13s   %s" "$hop_num" "$hop_ip" "$hop_loss%" "*" "${white}(No reply)${default}")"
			fi
			HopPrint "${hop_output}"
			continue # jump to the next hop
		fi

		# do a reverse DNS lookup for the IP
		hostname=$(RdnsLookup "$hop_ip")

		# check for routing loops, if so fail immediately
		if [ "$hop_num" -ge 2 ]; then
			prev_hop=${tracehops_array[$(( hop_num-1 ))]}
			if [ "$hop_ip" = "$prev_hop" ]; then
				ROUTING_LOOP=true
				break
			fi
		fi
		if [ "$hop_num" -ge 4 ]; then
			# detect routing loops
			two_hops_ago=${tracehops_array[$(( hop_num-2 ))]}
			three_hops_ago=${tracehops_array[$(( hop_num-3 ))]}
			if [ "$hop_ip" = "$two_hops_ago" ] && [ "$prev_hop" = "$three_hops_ago" ]; then
				ROUTING_LOOP=true
				break
			fi
		fi
		# AS DATA lookup
		# check if it's the last hop
		[[ "$hop_ip" = "$host_to_trace" ]] && LAST_HOP=true
		LookupASNAndRouteFromIP "$hop_ip"
		# check if IP is a bogon
		if [ "$IS_BOGON" = true ]; then
			asn_data="$bogon_tag"
			pwhois_output=""
		else
			# Hop IP is not a bogon address. Proceed with lookup of hop data
			if [ "$UNANNOUNCED_PREFIX" = true ]; then
				# No data in the Team Cymru DB. Check to see if the ip is assigned to an IXP, or fall back to generic whois.
				WhoisIP "$hop_ip" >/dev/null # don't display this, we're being parsed off-screen
				hop_asn="${red}N/A (address not announced)${default}"
				hop_org="$pwhois_org"
				hop_net="$pwhois_net"
				[[ -n "$found_route" ]] && hop_net+=" ($found_route)"
				hop_typ="$ip_type_data"
				hop_geo="$pwhois_geo"
				hop_rep="$ip_rep_data"
				if [ -n "$ixp_data" ]; then
					# this hop is an IXP
					ixp_tag="${bluebg} IXP ${default}"
					asn_data="${ixp_tag} ${blue}${ixp_data}${default}"
					hop_org="${ixp_tag} ${blue}${ixp_data}${default}"
					aspath_entry=$(printf "%-6s  ${blue}%s${default}" "$ixp_tag" "$ixp_data")
					aspath_array+=("$aspath_entry")
				else
					# no data found and not an IXP hop, try retrieving relevant info from a generic whois lookup
					hop_whois_data=$(echo -e "$full_whois_data" | grep -i -m2 -E "^netname:|^orgname:|^org-name:|^descr:" | cut -d ':' -f 2 | sed 's/^[ \t]*//' | while read -r line; do echo -n "$line / "; done | sed 's/ \/ $//')
					if [ -z "$hop_whois_data" ]; then
						asn_data="${yellow}(No data)${default}"
					else
						asn_data="${yellow}(${hop_whois_data})${default}"
					fi
				fi
			else
				# $hop_ip belongs to an announced prefix
				asn_data="${red}[AS$found_asn] ${green}$found_asname${default}"
				# avoid adding the same AS multiple times in a row in the summary path
				aspath_entry=$(printf "${red}%-6s ${green}%s${default}" "$found_asn" "$(echo "$found_asname" | cut -d ',' -f 1)" )
				if [[ "${aspath_array[-1]}" != "$aspath_entry" ]]; then
					aspath_array+=("$aspath_entry")
				fi
			fi
			if [ "$DETAILED_TRACE" = true ] && [ "$UNANNOUNCED_PREFIX" = false ]; then
				hop_asn="$found_asn"
				hop_prefix="$found_route"

				# run a pWhois lookup if the hop is within an announced prefix
				PwhoisLookup "$hop_ip"

				# in the event where Cymru has data, but pWhois doesn't, run a WhoisIP to fetch generic whois info
				# specifying the "generic_whois_lookup_only" parameter in order not to run pWhois/IXP lookups again
				[[ -z "$pwhois_output" ]] && WhoisIP "$hop_ip" "generic_whois_lookup_only" >/dev/null # don't display this, we're being parsed off-screen
				hop_org="$pwhois_org"
				hop_net="$pwhois_net"
				hop_typ="$ip_type_data"
				hop_geo="$pwhois_geo"
				hop_rep="$ip_rep_data"
			fi
		fi

		# DNS data (only used if a hostname was resolved)
		if [ -n "$hostname" ] && [ ! "$hostname" = "-" ]; then
			hop_ip="$hostname ($hop_ip)"
		fi
		# IXP coloring
		[[ -z "$ixp_tag" ]] && hop_ip="${white}${hop_ip}${default}" || hop_ip="${blue}${hop_ip}${default}"

		# print trace hop info
		if [ "$DETAILED_TRACE" = false ]; then
			hop_output="$(printf "%3s. %-$((output_width-51))s %6s${default} %10s ms   %s" "$hop_num" "${hop_ip}" "$hop_loss%" "${hop_ping}" "$asn_data")"
		else
			trailing_line=$(printf '%.0s═' $(seq $((border_width-${#hop_ip}))) )
			hop_output="$(printf "${border_color}╔═[${default}%3s. %s ${border_color}]%s╗${default}\n" "$hop_num" "${hop_ip}" "$trailing_line")"
			hop_output+="\n        ├${bluebg}RTT${default} ${white}${hop_ping} ms${default}\n"
			hop_output+="        ├${bluebg}LOS${default} ${hop_loss}%${default} packet loss${default}"
			# only add ASN data when not an IXP, otherwise we'll have duplicate data when ORG gets printed later
			if [ -z "$ixp_tag" ]; then
				# if it's a bogon address it's going to be the last branch of the displayed tree
				if [ "$IS_BOGON" = true ]; then
					hop_output+="\n        └${bluebg}TYP${default} $asn_data${default}"
				else
					hop_output+="\n        ├${bluebg}ASN${default} $asn_data${default}"
				fi
			fi
		fi
		HopPrint "$hop_output"

		if [ "$DETAILED_TRACE" = true ] && [ -n "$hop_asn" ]; then
			if [ -n "$found_asname" ]; then
				# only run RPKI lookups if the prefix is announced
				RPKILookup "$found_asn" "$hop_prefix"
				if [ "$INVALID_ROA" = true ]; then
					# notify user of possible BGP hijack/route leak
					aspath_array[-1]+=" ${redbg} ─> WARNING: POSSIBLE ROUTE LEAK / BGP HIJACK ${default}"
				fi
			else
				rpki_output="${red}N/A (hop address not announced)${default}"
			fi
			# compose hop detail output
			# 1. hop ASN, ORG, NET, ROA
			hop_details=""
			[[ "$DETAILED_TRACE" = false ]] && hop_details="       ├${bluebg}ASN${default} ${red}${hop_asn}${default}\n"
			hop_details+="        ├${bluebg}ORG${default} ${green}${hop_org}${default}\n"
			hop_details+="        ├${bluebg}NET${default} ${yellow}${hop_net}${default}\n"
			hop_details+="        ├${bluebg}ROA${default} ${rpki_output}\n"
			# 2. hop TYP (optional, only if hop is a particular IP type (anycast/hosting/etc))
			[[ -n "$hop_typ" ]] && hop_details+="        ├${bluebg}TYP${default}${hop_typ}${default}\n"
			# 3. hop GEO, REP
			hop_details+="        ├${bluebg}GEO${default} ${magenta}${hop_geo}${default}\n"
			hop_details+="        └${bluebg}REP${default} ${hop_rep}${default}"
			[[ "$DETAILED_TRACE" = false ]] && hop_details+="\n"
			# display hop details on screen
			HopPrint "$hop_details"
			[[ "$DETAILED_TRACE" = true ]] && HopPrint "\n"
		elif [ "$DETAILED_TRACE" = true ]; then
			# PWHOIS lookups ON, but no valid hop data (e.g. no-reply hop). Just add a newline
			[[ "$DETAILED_TRACE" = true ]] && HopPrint "\n"
		fi
		[[ "$LAST_HOP" = true ]] && break
	done
	# mtr output parsing complete
	if [ "$LAST_HOP" = false ]; then
		# last hop wasn't our target IP. Add a missing last hop to the trace.
		mtr_end_msg="${redbg} no route to host"
		[[ "$ROUTING_LOOP" = true ]] && mtr_end_msg+=" (routing loop detected)"
		mtr_end_msg+=" ${default}"
		# print hop info with final error message
		if [ "$DETAILED_TRACE" = false ]; then
			HopPrint "$(printf "%3s. %-$((output_width-51))s ${lightred}%11s%%${default} %13s   %s" "$hop_num" "$mtr_end_msg" "100" "*" "${white}(No reply)${default}")"
		else
			upper_border="${border_color}╔$(printf '%.0s═' $(seq "$border_width"))╗${default}"
			lower_border="${border_color}╚$(printf '%.0s═' $(seq "$border_width"))╝${default}"
			HopPrint "${upper_border}\n  ${mtr_end_msg}\n${lower_border}"
		fi
		aspath_array+=("${mtr_end_msg}${default}")
	fi

	endtime=$(date +%s)
	runtime=$((endtime-starttime))
	StatusbarMessage ""
	echo -e "\nTrace complete in $runtime seconds.\n"

	BoxHeader "AS path to $userinput"
	echo -en "\n  "
	for as in "${aspath_array[@]}"; do
		if [ "$as" = "${aspath_array[0]}" ]; then
			echo -en "${as} ${yellow}(Local AS)${default}"
		else
			echo -en "${as}${default}"
		fi
		if [ "$as" != "${aspath_array[-1]}" ]; then
			echo -en "\n ╭╯\n ╰"
		fi
	done
	echo -e "\n"
}

SearchByOrg(){
	unset orgs
	declare -a orgs
	echo ""
	if [ "$ORG_FILTER" = false ]; then
		StatusbarMessage "Searching for organizations matching ${bluebg}$1${lightgreybg}"
		full_org_search_data=$(whois -h whois.pwhois.org "registry org-name=$1")
		original_organizations=$(echo -e "$full_org_search_data" | grep -E "^Org-Name:" | cut -d ':' -f 2- | sed 's/^ //g' | sort -uf)
		total_orgsearch_results=$(echo -e "$original_organizations" | wc -l)
		organizations="$original_organizations"
	else
		# user chose to apply a search filter to a previous query
		if [ ${#orgfilters_array[@]} -eq 0 ] && [ ${#excl_orgfilters_array[@]} -eq 0 ]; then
			# user deleted all search filters. Revert to original query result
			organizations="$original_organizations"
			ORG_FILTER=false
		else
			StatusbarMessage "Applying filters"
			filtered_org="$original_organizations"
			# parse all inclusion filters
			for filter in "${orgfilters_array[@]}"; do
				apply_filter=$(echo -e "$filtered_org" | grep -i -- "$filter")
				if [ -z "$apply_filter" ]; then
					StatusbarMessage ""
					echo -en "${yellow}Warning: No results found for ${bluebg}${filter}${default}"
					sleep 2
					# remove last filter term
					unset 'orgfilters_array[${#orgfilters_array[@]}-1]'
				else
					filtered_org="$apply_filter"
				fi
			done
			# parse all exclusion filters
			for filter in "${excl_orgfilters_array[@]}"; do
				apply_filter=$(echo -e "$filtered_org" | grep -i -v -- "$filter")
				if [ -z "$apply_filter" ]; then
					StatusbarMessage ""
					echo -en "${yellow}Warning: No more results found if excluding ${bluebg}${filter}${default}"
					sleep 2
					# remove last filter term
					unset 'excl_orgfilters_array[${#excl_orgfilters_array[@]}-1]'
				else
					filtered_org="$apply_filter"
				fi
			done
			# have we removed all filters (because of no matches)? go back to unfiltered results
			if [ ${#orgfilters_array[@]} -eq 0 ] && [ ${#excl_orgfilters_array[@]} -eq 0 ]; then
				ORG_FILTER=false
				echo ""
			fi
			organizations="$filtered_org"
		fi
	fi
	for orgname in $organizations; do
		orgs+=("$orgname")
	done
	StatusbarMessage ""

	if [ ${#orgs[@]} -eq 0 ]; then
		# company search yielded no results
		PrintErrorAndExit "Error: no organizations found"
	fi

	# Menu showing loop
	while true; do
		ShowMenu
		searchresults=""
		[[ "$LOOKUP_ALL_RESULTS" == true ]] && orgs_to_lookup=("${orgs[@]}") || orgs_to_lookup=("$org")
		for org in "${orgs_to_lookup[@]}"; do
			orgids=$(echo -e "$full_org_search_data" | grep -i -E -B1 "Org-Name: $org$" | grep "Org-ID" | cut -d ':' -f 2- | sed 's/^ //g')
			NO_ERROR_ON_INTERRUPT=true
			for ipversion in 4 6; do
				NO_RESULTS=true
				searchresults+=$(BoxHeader "IPv${ipversion} networks for organization \"${org}\"")
				# iterate over Org-IDs related to the company (in case of multiple Org-IDs for a single Org-Name)
				for orgid in $orgids; do
					StatusbarMessage "Looking up IPv${ipversion} networks for organization ${bluebg}$org${lightgreybg} (Org-ID: ${bluebg}${orgid}${lightgreybg})"
					netblocks_output=""
					if [ "$ipversion" = "4" ]; then
						# Parse IPv4 NETBLOCKS
						netblocks=$(whois -h whois.pwhois.org "netblock org-id=${orgid}" | grep -E "^\*>")
						netblocks_header="            IPv4 NET RANGE                | INFO"
						for netblock in $netblocks; do
							prefix=$(echo -e "$netblock" | cut -d '>' -f 2 | cut -d '|' -f 1)
							netname=$(echo -e "$netblock" | cut -d '>' -f 2 | cut -d '|' -f 2 | tr -d ' ')
							netblock_type=$(echo -e "$netblock" | cut -d '>' -f 2 | cut -d '|' -f 3 | tr -d ' ')
							if [ "$netblock_type" = "unknown" ]; then
								nettype=""
							else
								nettype=" (${yellow}$netblock_type${default})"
							fi
							regdate=$(echo -e "$netblock" | cut -d '>' -f 2 | cut -d '|' -f 4 | tr -d ' ')
							if [ "$HAVE_IPCALC" = true ]; then
								# deaggregate IPv4 netblocks into CIDR prefixes for readability
								prefix_spacing=19
								trimmed_prefix=$(echo "$prefix" | tr -d ' ')
								prefix=$(ipcalc -r "$trimmed_prefix" | grep -A1 "deaggregate" | tail -n 1)
							else
								# no ipcalc, use direct pWhois output
								prefix_spacing=41
							fi
							netblocks_output+=$(printf "\n${blue}%${prefix_spacing}s${default} | ${green}%-45s${default} - Registered: ${magenta}%s${default}%s" "$prefix" "$netname" "$regdate" "$nettype")
						done
						[[ "$HAVE_IPCALC" = true ]] && netblocks_header="    IPv4 PREFIX     |       INFO"
					else
						# Parse IPv6 NETBLOCKS
						netblocks=$(whois -h whois.pwhois.org "netblock6 org-id=${orgid}" | grep -E "^Net-(Range|Name|Handle|Type)|^Register-Date" |\
							cut -d ':' -f 2- |\
							sed 's/^ //g' |\
							awk '{if (NR%5) {ORS=""} else {ORS="\n"}{print $0"|"}}') # cheers https://stackoverflow.com/a/35315421/5377165
						netblocks_header="                       IPv6 NET RANGE                         | INFO"
						for netblock in $netblocks; do
							prefix=$(echo -e "$netblock" | cut -d '|' -f 1)
							netname=$(echo -e "$netblock" | cut -d '|' -f 2)
							nethandle=$(echo -e "$netblock" | cut -d '|' -f 3)
							netname+=" (${nethandle})"
							netblock_type=$(echo -e "$netblock" | cut -d '|' -f 4)
							if [ "$netblock_type" = "unknown" ]; then
								nettype=""
							else
								nettype=" (${yellow}$netblock_type${default})"
							fi
							regdate=$(echo -e "$netblock" | cut -d '|' -f 5)
							prefix_spacing=61
							netblocks_output+=$(printf "\n${blue}%${prefix_spacing}s${default} | ${green}%-45s${default} - Registered: ${magenta}%s${default}%s" "$prefix" "$netname" "$regdate" "$nettype")
						done
					fi
					if [ -n "$netblocks_output" ]; then
						# Print out netblocks
						NO_RESULTS=false
						searchresults+=$(echo -e "\n${red}Org-ID: ${magenta}${orgid}${red}${default}\n${netblocks_header}${netblocks_output}")
						searchresults+="\n"
					fi
				done
				[[ "$NO_RESULTS" = true ]] && searchresults+="\n\t${red}No results found${default}\n"
			done
		done
		NO_ERROR_ON_INTERRUPT=false
		StatusbarMessage ""
		echo -e "$searchresults\n${yellow}────────────────────────────────────────────────────${default}"
		# let the user choose if they want to run a quick IP lookup
		while true; do
			echo -e "\n- Enter any ${blue}IP/Prefix${default} to look it up or"
			echo -e "- Press ${yellow}ENTER${default} to return to the menu:\n"
			echo -n ">> "
			read -r choice
			# check if it's an IPv4/IPv6
			if [ -n "${choice}" ]; then
				input=$(echo "$choice" | sed 's/\/.*//g' | grep -Eo "$ipv4v6regex")
				if [ -n "$input" ]; then
					# valid IP
					echo ""
					StatusbarMessage "Looking up data for ${bluebg}${input}${lightgreybg}"
					LookupASNAndRouteFromIP "$input"
					(( longest=${#input}+1 ))
					WhoisIP "$input"
					PrintReputation "$input"
					StatusbarMessage ""
					continue
				else
					continue
				fi
			else
				# user pressed ENTER, go back to main organizations menu
				clear
				break
			fi
		done
	done
}

ShowMenu(){ # show selection menu for search-by-company results
	clear
	BoxHeader "Organizations matching \"$userinput\""
	if [ "$ORG_FILTER" = true ]; then
		num_inclusion_filters="${#orgfilters_array[@]}"
		num_exclusion_filters="${#excl_orgfilters_array[@]}"
		num_filters=$(( num_inclusion_filters+num_exclusion_filters ))
		[[ $num_filters = 1 ]] && s="" || s="s"
		ACTIVE_FILTERS_STRING=$'\n'"${bluebg}${black}${num_filters} Active filter${s}:${default}"

		# recap inclusion filters
		for filter in "${orgfilters_array[@]}"; do
			ACTIVE_FILTERS_STRING+=" ${lightgreybg}${filter}${default}"
		done

		# recap exclusion filters
		for filter in "${excl_orgfilters_array[@]}"; do
			ACTIVE_FILTERS_STRING+=" ${lightgreybg}${red}-${filter}${default}"
		done

		ACTIVE_FILTERS_STRING+=$'\n'
	else
		ACTIVE_FILTERS_STRING=""
	fi
	if [ "$HAVE_IPCALC" = true ]; then
		IPCALC_WARNING=""
	else
		IPCALC_WARNING=$'\n'"${yellow}Warning: program ${red}ipcalc${yellow} not found."$'\n'"Install it with ${green}apt install ipcalc${yellow}"$'\n'"to enable netblock->CIDR prefix aggregation.${default}"$'\n'
	fi
	PS3="${yellow}────────────────────────────────────────────────────${default}
$ACTIVE_FILTERS_STRING
${yellow}${#orgs[@]} of $total_orgsearch_results total results shown${default}

Choose an organization or enter:
- <${green}text${default}> to FILTER FOR A STRING
- <${blue}-${default}> to EXCLUDE A STRING
- <${blue}x${default}> to REMOVE ALL FILTERS
- <${blue}a${default}> to LOOKUP ALL RESULTS (max 10)
- <${blue}q${default}> to QUIT
$IPCALC_WARNING
>> "
	echo -e "${yellow}────────────────────────────────────────────────────${green}"
	COLUMNS=1
	set -o posix
	select choice in "${orgs[@]}"; do
		for org in "${orgs[@]}"; do
			if [[ "$org" = "$choice" ]]; then
				LOOKUP_ALL_RESULTS=false
				break 2
			fi
		done
		case "$REPLY" in
			"q"|"Q")
				echo ""
				exit 0
			;;
			"-")
				# add an exclusion filter
				echo -n "Enter a string to ${red}exclude${default}: "
				read -r exclusion_string
				excl_orgfilters_array+=("$exclusion_string")
				ORG_FILTER=true
				SearchByOrg
			;;
			"x"|"X")
				# reset filters
				if [ "$ORG_FILTER" = true ]; then
					unset orgfilters_array
					unset excl_orgfilters_array
					declare -a orgfilters_array
					declare -a excl_orgfilters_array
					SearchByOrg
				fi
			;;
			"a"|"A")
				# lookup all results
				if [ "${#orgs[@]}" -gt 10 ]; then
					echo -en "\n${redbg}Too many results! Please add some filters!${default}\n"
					sleep 2
					continue
				fi
				LOOKUP_ALL_RESULTS=true
				break
			;;
			*)
				# apply filter to the results
				orgfilters_array+=("$REPLY")
				ORG_FILTER=true
				SearchByOrg
			;;
		esac
	done
	set +o posix
	echo ""
}

PrintReputation(){
	# We already have it in $ip_rep_data since we called IPGeoRepLookup() previously
	printf "${white}%${indent}s${bluebg}REP${default} ${magenta}%s${default}\n\n" "└" "$ip_rep_data"
}

RPKILookup(){
	# $1=asn, $2=prefix
	found_rpkivalidity=""
	INVALID_ROA=false
	rpki_apioutput=$(curl -s "https://stat.ripe.net/data/rpki-validation/data.json?resource=$1&prefix=$2&sourceapp=nitefood-asn")
	is_valid_json=$(echo "$rpki_apioutput" | jq type 2>/dev/null)
	if [ -n "$is_valid_json" ]; then
		found_rpkivalidity=$(echo "$rpki_apioutput" | jq -r '.data.status' | tr '[:lower:]' '[:upper:]')
		found_rpkiroacount=$(echo "$rpki_apioutput" | jq '.data.validating_roas | length')
		found_rpkiprefix=$(echo "$rpki_apioutput" | jq -r '.data.validating_roas[0].prefix')
		found_rpkiorigins=$(echo "$rpki_apioutput" | jq -r '.data.validating_roas[] | select (.prefix=="'"$found_rpkiprefix"'") | .origin')
		found_rpkiorigin="["
		origin_count=0
		for origin in $found_rpkiorigins; do
			[[ "$origin_count" -gt 0 ]] && found_rpkiorigin+=", "
			found_rpkiorigin+="AS$origin"
			(( origin_count++ ))
		done
		found_rpkiorigin+="]"

		found_rpkimaxlength=$(echo "$rpki_apioutput" | jq -r '.data.validating_roas[0].max_length')
		# TODO: iterate over ROAs (.data.validatingRoas[]) to give deeper source RIR insight
		#found_rpkisource=$(echo "$rpki_apioutput" | jq -r '.data.validatingRoas[0].source')
		case "$found_rpkivalidity" in
			"VALID")
				[[ "${found_rpkiroacount}" -gt 1 ]] && s="s" || s=""
				rpki_output="${green}✓ VALID (${found_rpkiroacount} ROA$s found)${default}"
				;;
			"UNKNOWN")
				rpki_output="${yellow}✓ UNKNOWN (no ROAs found)${default}"
				;;
			"INVALID_ASN")
				INVALID_ROA=true
				if [ "$found_rpkiorigin" = "0" ]; then
					rpki_output="${red}❌ ${found_rpkivalidity} (no Origin authorized to announce Prefix '${found_rpkiprefix}' with Max-Length=${found_rpkimaxlength})${default}"
				else
					rpki_output="${red}❌ ${found_rpkivalidity} (expected Origin(s): ${found_rpkiorigin} for Prefix '${found_rpkiprefix}' with Max-Length=${found_rpkimaxlength})${default}"
				fi
				;;
			"INVALID_LENGTH")
				INVALID_ROA=true
				rpki_output="${red}❌ ${found_rpkivalidity} (expected Max-Length=${found_rpkimaxlength} for Prefix '${found_rpkiprefix}')${default}"
				;;
		esac
	else
		rpki_output="${yellow}? (WRONG RPKI DATA or problem accessing RIPEStat API)${default}"
	fi
}

IsIXP() {
	# input ($1) is an IPv4/v6.
	ixp_full_ix_data=""
	ixp_data=""
	ixp_geo=""
	input_is_ipv6=false
	if [ "$IXP_DETECTION" = true ]; then
		echo -e "$1" | grep -q ':' && input_is_ipv6=true
		# Update IXP prefixes from PeeringDB if necessary
		# use the appropriate (v4/v6) IXP prefix dataset
		if [ "$input_is_ipv6" = false ]; then
			# if input is an IPv4, speedup lookups further by grabbing only IXP prefixes starting with the same two octets
			# we can afford filtering based on the first two octets since the largest individual IXP prefix is around /20
			first_octets=$(echo "${1}." | cut -d '.' -f 1,2)
			peeringdb_ipv4_dataset=$(curl -s "https://www.peeringdb.com/api/ixpfx?prefix__startswith=$first_octets&protocol__in=IPv4")
			peeringdb_dataset="$peeringdb_ipv4_dataset"
		else
			# only fetch IPv6 dataset once, since we don't filter it for prefixes
			[[ -z "$peeringdb_ipv6_dataset" ]] && peeringdb_ipv6_dataset=$(curl -s "https://www.peeringdb.com/api/ixpfx?protocol__in=IPv6")
			peeringdb_dataset="$peeringdb_ipv6_dataset"
		fi
		ixp_prefixes=$(echo -e "$peeringdb_dataset" | jq -r '.data[].prefix')
		# search for input prefix through PeeringDB IXP prefix list
		for prefix in $ixp_prefixes; do
			if echo "$1" | grepcidr -f <(echo "$prefix") &>/dev/null; then
				# the IP is part of an IXP prefix
				# Query PeeringDB to match an IXP for that prefix.
				ixlan_id=$(echo "$peeringdb_dataset" | jq -r '.data[] | select(.prefix == "'"$prefix"'") | .ixlan_id')
				ixp_full_ix_data=$(curl -s "https://www.peeringdb.com/api/ix/$ixlan_id")
				ixp_data=$(echo "$ixp_full_ix_data" | jq -r '.data[0].name, .data[0].name_long' | paste -sd '|' - | awk -F'|' '{print $1 " (" $2 ")"}')
				ixp_geo=$(echo "$ixp_full_ix_data" | jq -r '.data[0].org.city')
				ixp_state=$(echo "$ixp_full_ix_data" | jq -r '.data[0].org.state')
				ip_type_data=" ${lightgreybg} IXP ${default}"
				[[ -n "$ixp_state" ]] && ixp_geo+=" ($ixp_state)"
				break
			fi
		done
	fi
}

GetIXPresence(){
	asn="$1"
	ixps=""
	outputix=""
	netlist=$(curl -s "https://www.peeringdb.com/api/net?asn__in=$asn" | jq -r '.data[].id')
	if [ -n "$netlist" ]; then
		for net in $netlist; do
			ixps+=$(curl -s "https://www.peeringdb.com/api/net/$net" | jq -r '.data[].netixlan_set[].name')
		done
		if [ -n "$ixps" ]; then
			for ix in $(echo "$ixps" | sort -u); do
				[[ -n "$outputix" ]] && outputix+=" | "
				outputix+="${blue}${ix}${default}"
			done
		else
			outputix="${redbg} NONE ${default}"
		fi
	else
		outputix="${redbg} NONE ${default}"
	fi
	echo -e "$outputix"
}

IPGeoRepLookup(){
	StatusbarMessage "Collecting geolocation and classification data"
	# fetch preferred geolocation and anycast data from RIPE IPmap
	ipmap_output=$(curl -m4 -s "https://ipmap.ripe.net/api/v1/locate/$1/best")

	# fetch fallback geolocation and ip type (is mobile?) data from ip-api.com
	ipapi_output=$(curl -s "http://ip-api.com/json/$1?fields=status,message,country,countryCode,regionName,city,mobile,proxy,hosting")
	ipapi_status=$(echo "$ipapi_output" | jq -r '.status')
	if [ "$ipapi_status" = "fail" ]; then
		ipapi_errmsg=$(echo "$ipapi_output" | jq -r '.message')
		ip_rep_data="${red}IP-API ERROR:${default} ${ipapi_errmsg}"
	else
		IS_MOBILE=$(echo "$ipapi_output" | jq -r '.mobile')
		IS_PROXY=$(echo "$ipapi_output" | jq -r '.proxy')
		IS_HOSTING=$(echo "$ipapi_output" | jq -r '.hosting')
	fi

	IS_ANYCAST=""
	if [[ -z $(echo "$ipmap_output" | jq 'select (.error != null) | .error') ]]; then
		IS_ANYCAST=$(echo "$ipmap_output" | jq '.metadata.service.contributions."'"$1"'".engines[] | select (.engine=="simple-anycast") | .metadata.anycast')
	fi

	ip_geo_data=""
	ipmap_location_data=$(echo "$ipmap_output" | jq 'select (.location != null) | .location')
	if [ -n "$ipmap_location_data" ]; then
		# RIPE IPmap has (at least some) geo data about this address, check city/region
		ipmap_city=$(echo "$ipmap_location_data" | jq -r 'select (.cityNameAscii != null) | .cityNameAscii')
		ipmap_region=$(echo "$ipmap_location_data" | jq -r 'select (.stateName != null) | .stateName')
	fi
	if [ -n "$ipmap_city" ] && [ -n "$ipmap_region" ]; then
		# RIPE IPmap has full geo data, continue
		ipmap_cc=$(echo "$ipmap_location_data" | jq -r '.countryCodeAlpha2')
		ipmap_country_name=$(echo "$ipmap_location_data" | jq -r '.countryName')
		if [ -n "$ipmap_city" ] && [ -n "$ipmap_region" ] && [ -n "$ipmap_cc" ]; then
			ip_geo_data="$ipmap_city, $ipmap_region ($ipmap_cc)"
		elif [ -n "$ipmap_region" ] && [ -n "$ipmap_country_name" ]; then
			ip_geo_data="$ipmap_region ($ipmap_country_name)"
		elif [ -n "$ipmap_country_name" ]; then
			ip_geo_data="$ipmap_country_name"
		fi
	elif [ "$ipapi_status" = "success" ]; then
		# IPmap has incomplete/no data about this address, fallback to ip-api.com
		ipapi_city=$(echo "$ipapi_output" | jq -r '.city')
		ipapi_region=$(echo "$ipapi_output" | jq -r '.regionName')
		ipapi_cc=$(echo "$ipapi_output" | jq -r '.countryCode')
		ipapi_countryname=$(echo "$ipapi_output" | jq -r '.country')
		if [ -n "$ipapi_city" ] && [ -n "$ipapi_region" ] && [ -n "$ipapi_cc" ]; then
			ip_geo_data="$ipapi_city, $ipapi_region ($ipapi_cc)"
		elif [ -n "$ipapi_region" ] && [ -n "$ipapi_countryname" ]; then
			ip_geo_data="$ipapi_region ($ipapi_countryname)"
		elif [ -n "$ipapi_countryname" ]; then
			ip_geo_data="$ipapi_countryname"
		fi
	fi

	# IP type identification
	ip_type_data=""
	[[ "$IS_ANYCAST" = true ]] && ip_type_data+=" ${yellowbg} Anycast IP ${default}"
	[[ "$IS_MOBILE" = true ]] && ip_type_data+=" ${yellowbg} Mobile network ${default}"
	[[ "$IS_PROXY" = true ]] && ip_type_data+=" ${yellowbg} Proxy host ${default}"
	[[ "$IS_HOSTING" = true ]] && ip_type_data+=" ${yellowbg} Hosting/DC ${default}"

	# Reputation lookup (stopforumspam.org) and threat analisys (ipqualityscore.com)
	ip_rep_data="${green}✓ GOOD${default}"
	is_blacklisted=$(curl -s "http://api.stopforumspam.org/api?json&ip=$1" | jq -r '.ip.appears')
	if [ "$is_blacklisted" = "1" ]; then
		# IP is blacklisted by StopForumSpam. Lookup detailed reputation data on IPQualityScore
		ip_rep_data="${red}❌ BAD (on stopforumspam.org)${default}"
		if [ -n "$IQS_TOKEN" ]; then
			iqs_output=$(curl -s "https://ipqualityscore.com/api/json/ip/$IQS_TOKEN/$1")
			iqs_success=$(echo "$iqs_output" | jq -r '.success')
			if [ "$iqs_success" = true ]; then
				iqs_score=$(echo "$iqs_output" | jq -r '.fraud_score')
				iqs_proxy=$(echo "$iqs_output" | jq -r '.proxy')
				iqs_vpn=$(echo "$iqs_output" | jq -r '.active_vpn')
				iqs_tor=$(echo "$iqs_output" | jq -r '.active_tor')
				iqs_recentabuse=$(echo "$iqs_output" | jq -r '.recent_abuse')
				iqs_bot=$(echo "$iqs_output" | jq -r '.bot_status')
				iqs_crawler=$(echo "$iqs_output" | jq -r '.is_crawler')
				if [ "$iqs_score" -lt 40 ]; then
					ip_rep_data="✓ GOOD"
					ip_rep_color="$green"
				elif [ "$iqs_score" -lt 75 ]; then
					ip_rep_data="✓ AVERAGE"
					ip_rep_color="$green"
				elif [ "$iqs_score" -lt 85 ]; then
					ip_rep_data="! SUSPICIOUS"
					ip_rep_color="$yellow"
				else
					ip_rep_data="❌ BAD"
					ip_rep_color="$red"
				fi
				ip_rep_data="${ip_rep_color}${ip_rep_data} (Threat Score ${iqs_score}%)${default}"
				[[ "$iqs_recentabuse" = true ]] && ip_rep_data+=" ${redbg} RECENT ABUSER ${default}"
				[[ "$iqs_bot" = true ]] && ip_rep_data+=" ${redbg} BOT ${default}"
				[[ "$iqs_proxy" = true ]] && ip_rep_data+=" ${redbg} PROXY ${default}"
				[[ "$iqs_vpn" = true ]] && ip_rep_data+=" ${redbg} VPN ${default}"
				[[ "$iqs_tor" = true ]] && ip_rep_data+=" ${redbg} TOR EXIT NODE ${default}"
				[[ "$iqs_crawler" = true ]] && ip_rep_data+=" ${redbg} CRAWLER ${default}"
			else
				iqs_errmsg=$(echo "$iqs_output" | jq -r '.message')
				ip_rep_data+=" ${redbg} ERR ${default} (IpQualityScore API said: $iqs_errmsg)"
			fi
		fi
	fi
	StatusbarMessage ""
}

PrintErrorAndExit(){
	echo -e "\n${redbg}${1}${default}\n"
	tput sgr0
	exit 1
}

Ctrl_C() {
	if [ "$NO_ERROR_ON_INTERRUPT" = true ]; then
		StatusbarMessage ""
		tput sgr0
		ShowMenu
	else
		PrintErrorAndExit "Interrupted"
	fi
}

BoxHeader() { # cheers https://unix.stackexchange.com/a/70616
	local s="$*"
	echo -e "\n${white}╭─${s//?/─}─╮
│ ${yellow}${s}${white} │
╰─${s//?/─}─╯"
	tput sgr 0
}

StatusbarMessage() { # invoke without parameters to delete the status bar message
	if [ -n "$statusbar_message" ]; then
		# delete previous status bar message
		blank_line=$(printf "%.0s " $(seq "$terminal_width"))
		printf "\r%s\r" "$blank_line"
	fi
	if [ -n "$1" ]; then
		statusbar_message="$1"
		max_msg_size=$((terminal_width-23))
		if [ "${#statusbar_message}" -gt "${max_msg_size}" ]; then
			statusbar_message="${lightgreybg}${statusbar_message:0:$max_msg_size}${lightgreybg}..."
		else
			statusbar_message="${lightgreybg}${statusbar_message}"
		fi
		statusbar_message+="${lightgreybg} (press CTRL-C to cancel)...${default}"
		echo -en "$statusbar_message"
	fi
}

WhatIsMyIP() {
	# only lookup local WAN IP once
	[[ -n "$local_wanip" ]] && return
	# retrieve local WAN IP (v6 takes precedence) from ipify
	local_wanip=$(curl -s api64.ipify.org)
	# check if we default to an IPv6 internet connection
	if echo "$local_wanip" | grep -q ':'; then
		HAVE_IPV6=true
	fi
}

CheckPrerequisites() {
	saveIFS="$IFS"
	IFS=' '
	prerequisite_tools="jq whois host curl" # mandatory tools
	optionals_tools="mtr ipcalc grepcidr"	# optional tools
	missing_tools=""
	disabled_features=""
	HARD_FAIL=false

	HAVE_IPCALC=true
	IXP_DETECTION=true

	#* BASH version check
	bash_major=$(echo "${BASH_VERSION}" | cut -d '.' -f 1)
	bash_minor=$(echo "${BASH_VERSION}" | cut -d '.' -f 2)
	bash_version_too_low=false
	if [ "$bash_major" -lt 4 ]; then
		bash_version_too_low=true
	elif [ "$bash_major" -eq 4 ] && [ "$bash_minor" -lt 2 ]; then
		bash_version_too_low=true
	fi
	[[ "$bash_version_too_low" = true ]] && PrintErrorAndExit "Error: BASH version must be >= 4.2 (you are running v${BASH_VERSION})"

	#* Mandatory tools checking (hard fail if not found)
	for tool in $prerequisite_tools; do
		if [ -z "$(command -v "$tool")" ]; then
			missing_tools+="\n - $tool"
			HARD_FAIL=true
		fi
	done

	#* Optional tools checking (no hard fail if not found, but some features disabled)
	for tool in $optionals_tools; do
		if [ -z "$(command -v "$tool")" ]; then
			missing_tools+="\n - $tool"
			case "$tool" in
				"mtr")
					disabled_feat="AS path tracing"
					TRACEASNPATH=false
					;;
				"ipcalc")
					disabled_feat="CIDR deaggregation"
					HAVE_IPCALC=false
					;;
				"grepcidr")
					disabled_feat="IXP prefix detection"
					IXP_DETECTION=false
					;;
			esac

			disabled_features+="\n - ${disabled_feat}"
		fi
	done

	if [ -n "$missing_tools" ]; then
		BoxHeader "! WARNING !"
		echo -e "\nThe following tools were not found on this system:" \
				"${red} ${missing_tools}${default}"

		if [ -n "$disabled_features" ]; then
			echo -e "\nThe following features will be disabled:" \
					"${yellow}${disabled_features}${default}"
		fi

		echo -e "\nPlease install the necessary prerequisite packages\nfor your system by following these instructions:" \
				"\n\n>> ${blue}https://github.com/nitefood/asn#prerequisite-packages${default} <<\n"

		[[ "$HARD_FAIL" = true ]] && PrintErrorAndExit "Can not continue without (at least) the following tools: ${prerequisite_tools// /, }"

		echo -n "${lightgreybg}Press ENTER to continue...${default}"
		# shellcheck disable=SC2034
		read -r key
	fi

	IQS_TOKEN=""
	# Read ipqualityscore.com token from file
	if [ -r "$IQS_TOKEN_FILENAME" ]; then
		IQS_TOKEN=$(tr -d ' \n\r\t' < "$IQS_TOKEN_FILENAME")
	fi
	if [ -z "$IQS_TOKEN" ]; then
		# warn the user about the absence of in-depth IP reputation API token
		echo -en "\n${yellow}────────────────────────────────────────────────────────────\n\t\t\tWARNING${default}" \
			"\n\n${white}No IPQualityScore token found, so disabling in-depth threat" \
			"\nanalysis and IP reputation lookups. Please visit" \
			"\n${blue}https://github.com/nitefood/asn#ip-reputation-api-token${white}" \
			"\nfor instructions on how to enable it." \
			"\n${yellow}────────────────────────────────────────────────────────────${default}\n"
	fi

	# check for `gdate` presence (MacOS coreutils), otherwise fall back to plain `date` (cheers @Antonio-Prado)
	if [ -x "$(command -v gdate)" ]; then
		date() { gdate "$@"; }
		export -f date
	fi

	IFS="$saveIFS"
}

# Get terminal width
terminal_width=$(tput cols)

# Color scheme
IFS=$'\n\t'
green=$'\e[32m'
magenta=$'\e[35m'
yellow=$'\e[33m'
white=$'\e[97m'
blue=$'\e[94m'
red=$'\e[31m'
black=$'\e[30m'
lightyellow=$'\e[38;5;220m'
lightred=$'\e[91m'
lightgreybg=$'\e[47m\e[30m'
bluebg=$'\e[44m\e[30m'
redbg=$'\e[30m\e[101m'
greenbg=$'\e[42m\e[30m'
yellowbg=$'\e[43m\e[30m'
default=$'\e[0m'

# External API token for ipqualityscore.com (IP reputation & threat analisys lookup)
IQS_TOKEN_FILENAME="$HOME/.asn/iqs_token"

# PeeringDB list of IXP prefixes
peeringdb_dataset=""
peeringdb_ipv6_dataset=""

# Signals trapping (interrupt/terminal resize)
NO_ERROR_ON_INTERRUPT=false
trap Ctrl_C INT
trap 'terminal_width=$(tput cols)' SIGWINCH

ipv4v6regex='[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}|(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|'\
'([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|'\
'([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|'\
':((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|'\
'(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|'\
'1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))' # cheers https://stackoverflow.com/a/17871737

# Check cmdline parameters
if [[ $# -lt 1 ]]; then
	PrintUsage
	exit 1
fi

FORCE_ORGSEARCH=false
SUGGEST_SEARCH=false

case "$1" in
	"-n"|"--notrace")
		if [[ $# -lt 2 ]]; then
			PrintUsage
			echo -e "Error: missing ${red}TARGET${default}\n"
			exit 1
		fi
		TRACEASNPATH=false
		DETAILED_TRACE=false
		userinput="$2"
		;;
	"-d"|"--detailed")
		if [[ $# -lt 2 ]]; then
			PrintUsage
			echo -e "Error: missing ${red}TARGET${default}\n"
			exit 1
		fi
		TRACEASNPATH=true
		DETAILED_TRACE=true
		userinput="$2"
		;;
	"-o"|"--organization")
		if [[ $# -lt 2 ]]; then
			PrintUsage
			echo -e "Error: missing ${red}TARGET${default}\n"
			exit 1
		else
			FORCE_ORGSEARCH=true
			userinput=$(echo "$@" | cut -d ' ' -f 2- | sed -e 's/^[ \t]*//')
		fi
		;;
	"-s"|"--suggest")
		if [[ $# -lt 2 ]]; then
			PrintUsage
			echo -e "Error: missing ${red}TARGET${default}\n"
			exit 1
		else
			SUGGEST_SEARCH=true
			userinput=$(echo "$@" | cut -d ' ' -f 2- | sed -e 's/^[ \t]*//')
		fi
		;;
	*)
		if [ "${1:0:1}" = "-" ]; then
			 PrintUsage
			 echo -e "Error: unknown option ${red}$1${default}\n"
			 exit 1
		else
			# defaults
			TRACEASNPATH=true
			DETAILED_TRACE=false
			ENABLE_ORGSEARCH=true
			# shellcheck disable=2124
			userinput="$@"
		fi
		;;
esac

#* Check prerequisite and optional tools
CheckPrerequisites

local_wanip=""
HAVE_IPV6=false
BoxHeader "ASN lookup for $userinput"

if [ "$FORCE_ORGSEARCH" = true ]; then
	# user passed the "-o|--organization" switch
	ORG_FILTER=false
	declare -a orgfilters_array
	declare -a excl_orgfilters_array
	SearchByOrg "$userinput"
	exit 0
fi

if [ "$SUGGEST_SEARCH" = true ]; then
	# user passed the "-s|--suggest" switch
	RIPESuggestASN "$userinput"
	exit 0
fi


input=$(echo "$userinput" | sed 's/\/.*//g' | grep -Eo "$ipv4v6regex")

if [ -z "$input" ]; then
	# Input is not an IP Address. Check if it is a number (ASN)
	asn=$(echo "$userinput" | sed 's/[a|A][s|S]//g' | grep -E "^[0-9]*$")
	if [ -z "$asn" ]; then
		# Input is not an ASN either. See if it's a hostname (includes at least one dot)
		if echo "$userinput" | grep -q "\."; then
			echo -e -n "\n${blue}- Resolving \"$userinput\"... "
			ip=$(ResolveHostnameToIPList "$userinput")
			if [ -z "$ip" ]; then
				echo -e "${red}Error: unable to resolve hostname${default}" \
						"\n\n(Hint: if you wanted to search by organization, try the ${blue}'-o'${default} switch)\n"
				exit 1
			fi
			numips=$(echo "$ip" | wc -l)
			[[ $numips = 1 ]] && s="" || s="es"
			echo -e "${blue}$numips IP address$s found:\n"
			# grab the longest IP to properly size output padding
			longest=0
			for singleip in $ip; do
				[[ ${#singleip} -gt $longest ]] && longest=${#singleip}
			done
			(( longest++ ))
			# output actual results
			ip_to_trace=""
			WhatIsMyIP
			for singleip in $ip; do
				LookupASNAndRouteFromIP "$singleip"
				WhoisIP "$singleip"
				PrintReputation "$singleip"
				# save the first IP from the dns lookup result
				[[ -z "$ip_to_trace" ]] && ip_to_trace="$singleip"
			done
			# Check if AS path tracing is requested
			if [ "$TRACEASNPATH" = true ]; then
				# In case of multiple IPs (DNS RR), trace the first one.
				# Additionally, if we're on an IPv6 connection, default to
				# tracing to the first resolved IPv6 address (if any)
				if [ "$HAVE_IPV6" = true ]; then
					first_ipv6=$(echo "$ip" | grep -m1 ':')
					[[ -n "$first_ipv6" ]] && ip_to_trace="$first_ipv6"
				fi
				TraceASPath "$ip_to_trace"
			fi
			tput sgr0
			echo ""
			exit 0
		else
			# not an IP, not an ASN, not a hostname. Consider it an Organization name unless a cmdline option was specified
			[[ -z "$ENABLE_ORGSEARCH" ]] && PrintErrorAndExit "Error: To search by organization, please pass the [-o|--organization] command line switch (or no switch at all)"
			ORG_FILTER=false
			declare -a orgfilters_array
			declare -a excl_orgfilters_array
			SearchByOrg "$userinput"
		fi
	else
		# Input is an ASN
		WhoisASN "$asn"
		if [ -z "$found_asname" ]; then
			PrintErrorAndExit "Error: no data found for AS${asn}"
		fi
		echo -e "\n${bluebg} AS Number ──────>${default} ${red}${asn}"
		echo -e "${bluebg} AS Name ────────>${default} ${green}${found_asname}"
		echo -e "${bluebg} Organization ───>${default} ${yellow}${found_org}"
		echo -e "${bluebg} AS Reg. date ───>${default} ${white}${found_createdate}"
		echo -en "${bluebg} Peering @IXPs ──>${default} "
		GetIXPresence "$asn"
		BoxHeader "BGP informations for AS${asn} (${found_asname})"
		echo ""
		QueryRipestat "${asn}"
		if [ -n "$ripestat_routing_data" ]; then
			echo -e "${bluebg} IPv4 Prefixes ─────>${default} ${green}${ripestat_ipv4}"
			echo -e "${bluebg} IPv6 Prefixes ─────>${default} ${yellow}${ripestat_ipv6}"
			echo -e "${bluebg} BGP Neighbours ────>${default} ${blue}${ripestat_bgp}${default}"
		fi
		if [ -n "$ripestat_neighbours_data" ]; then
			[[ -n "$upstream_peers" ]] && upstream_peers=$(echo -e "$upstream_peers") || upstream_peers="${redbg} NONE ${default}"
			[[ -n "$downstream_peers" ]] && downstream_peers=$(echo -e "$downstream_peers") || downstream_peers="${redbg} NONE ${default}"
			[[ -n "$uncertain_peers" ]] && uncertain_peers=$(echo -e "$uncertain_peers") || uncertain_peers="${redbg} NONE ${default}"
			BoxHeader "Peering informations for AS${asn} (${found_asname})"
			echo -e "\n${green}──────────────── Upstream Peers ────────────────${default}\n\n${upstream_peers}"
			echo -e "\n${yellow}─────────────── Downstream Peers ───────────────${default}\n\n${downstream_peers}"
			echo -e "\n${white}─────────────── Uncertain  Peers ───────────────${default}\n\n${uncertain_peers}\n"
		fi
		BoxHeader "Announced prefixes (aggregated) for AS${asn} (${found_asname})"
		echo -e "\n${green}───── IPv4 ─────${default}"
		[[ -n "$ipv4_inetnums" ]] && echo -e "${green}${ipv4_inetnums}${default}" || echo -e "\n${redbg} NONE ${default}"
		echo -e "\n${yellow}───── IPv6 ─────${default}"
		[[ -n "$ipv6_inetnums" ]] && echo -e "${yellow}${ipv6_inetnums}${default}" || echo -e "\n${redbg} NONE ${default}"
		tput sgr0
		echo ""
		exit 0
	fi
else
	# Input is an IP address
	# Perform IP lookup
	LookupASNAndRouteFromIP "$input"
	(( longest=${#input}+1 ))
	WhoisIP "$input"
	PrintReputation "$input"
	# Perform AS path tracing if requested
	[[ "$TRACEASNPATH" = true ]] && TraceASPath "$input"
	tput sgr0
	echo ""
	exit 0
fi
